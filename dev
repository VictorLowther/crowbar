#!/bin/bash

export LANG="C"
export LC_ALL="C"

GEM_RE='([^0-9].*)-([0-9].*)'

readonly currdir="$PWD"
export PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"
declare -A DEV_BRANCHES DEV_REMOTE_SOURCES DEV_REMOTE_BRANCHES DEV_ORIGIN_TYPES
declare -a DEV_REMOTES DEV_ALL_REMOTES
declare -A __AVAILABLE_REMOTES
# The generation of the dev tool this is.
readonly DEV_VERSION=2

# The key -> value mapping in DEV_BRANCHES defines child -> parent relations
# between branches.  A branch is considered a root branch if it has itself
# as a parent.
DEV_BRANCHES["master"]="master"
DEV_BRANCHES["openstack-os-build"]="master"
DEV_BRANCHES["hadoop-os-build"]="master"
DEV_BRANCHES["cloudera-os-build"]="master"
github_re='^https?://.*github\.com/([^/]+)'

# DEV_REMOTE_BRANCHES defines what branches in the main Crowbar repository
# should be pulled and synced with what remotes.
# Barclamps do care about remote branches.
DEV_REMOTE_BRANCHES["origin"]="master openstack-os-build hadoop-os-build cloudera-os-build"

# Source our config file if we have one
[[ -f $HOME/.build-crowbar.conf ]] && \
    . "$HOME/.build-crowbar.conf"

# Look for a local one.
[[ -f build-crowbar.conf ]] && \
    . "build-crowbar.conf"

# Location of the Crowbar checkout we are building from.
[[ $CROWBAR_DIR ]] || CROWBAR_DIR="${0%/*}"
[[ $CROWBAR_DIR = /* ]] || CROWBAR_DIR="$currdir/$CROWBAR_DIR"
[[ -f $CROWBAR_DIR/build_crowbar.sh && -d $CROWBAR_DIR/.git ]] || \
    die "$CROWBAR_DIR is not a git checkout of Crowbar!"
export CROWBAR_DIR

. "$CROWBAR_DIR/build_lib.sh" || exit 1
trap - 0 INT QUIT TERM

which gem &>/dev/null || \
    die "Rubygems not installed, and some of our helpers need a JSON gem."

gem list -i json &>/dev/null || \
    die "JSON gem not installed.  Please install it with gem install json."


get_repo_cfg() { in_repo git config --get "$1"; }
git_config_has() { git config --get "$1" &>/dev/null; }

remote_available() {
    local r urlbase url_re='^(https?|ssh|git)://([^/]+)'
    local -A remote_hash
    [[ $DEV_AVAILABLE_REMOTES ]] || return 0
    if [[ ${__AVAILABLE_REMOTES[$1]} ]]; then
	[[ ${__AVAILABLE_REMOTES[$1]} = true ]]
	return $?
    fi
    for r in ${DEV_AVAILABLE_REMOTES//origin/$(origin_remote)}; do
	crowbar_remote_exists "$r" || \
	    die "Unknown remote $r in DEV_AVAILABLE_REMOTES!"
	urlbase=$(get_repo_cfg "crowbar.remote.$r.urlbase")
	[[ $urlbase =~ $url_re ]] || continue
	remote_hash["${BASH_REMATCH[2]}"]=true
    done
    urlbase=$(get_repo_cfg "crowbar.remote.$1.urlbase")
    [[ $urlbase =~ $url_re ]] || return 1
    if [[ ${remote_hash["${BASH_REMATCH[2]}"]} ]]; then
	__AVAILABLE_REMOTES[$1]=true
	return 0
    else
	__AVAILABLE_REMOTES[$1]=false
	return 1
    fi
}

if [[ $DEV_GITHUB_PASSWD ]]; then
    debug "Migrating Github password information to $HOME/.netrc"
    for mach in github.com api.github.com; do
	grep -q "^$mach" "$HOME/.netrc" &>/dev/null && continue
	printf "\nmachine %s login %s password %s\n" \
	    "$mach" "$DEV_GITHUB_ID" "$DEV_GITHUB_PASSWD" >> "$HOME/.netrc"
    done
    chmod 600 "$HOME/.netrc"
    sed -ie 's/DEV_GITHUB_PASSWD=.*//' "$HOME/.build-crowbar.conf"
    debug "Please remove your embedded login information from the remote URLS."
fi


origin_remote() {
    local r
    for r in $(sorted_remotes); do
	git_remote_exists "$r" || continue
	echo "$r"
	return 0
    done
    return 1
}

barclamps_from_remote() {
    crowbar_remote_exists "$1" || die "Unknown remote $1"
    local rmode rtype rsha rname
    while read rmode rtype rsha rname; do
	[[ $rtype = */barclamp-* ]] || continue
	printf '%s\n' "${rtype##*/barclamp-}"
    done < <(in_repo git ls-tree -r "refs/remotes/$1/master" releases) | \
	sort -u
}

remote_for_build() {
    local r
    for r in $(sorted_remotes); do
	[[ $(in_repo git ls-tree "refs/remotes/$r/master" "releases/$1") ]] || continue
	echo "$r"
	return 0
    done
    return 1
}

current_build() { get_repo_cfg 'crowbar.build'; }

# Get the current release we are working on, which is a function of
# the currently checked-out branch.
current_release() {
    local rel
    rel=$(current_build) || \
	die "current_release: Cannot get current build information!"
    echo "${rel%/*}"
}

barclamp_exists_in_build() { 
    local build=${1%/*} bc=${1##*/}
    [[ -f $CROWBAR_DIR/releases/$build/barclamp-$bc ]]
}
build_exists() [[ -f $CROWBAR_DIR/releases/$1/barclamp-crowbar ]]
release_exists() [[ -d $CROWBAR_DIR/releases/$1/master ]]

# Find all barclamps for whatever.
barclamp_finder() {
    # $1 = directory under $CROWBAR_DIR/releases to look in.
    # $2 = regex to use as a filter.
    # $2 = Match in the RE to return.  Defaults to 1
    local b
    while read b; do
	[[ $b =~ $2 ]] || continue
	printf '%s\n' "${BASH_REMATCH[${3:-1}]}"
    done < <(find "$CROWBAR_DIR/releases/$1" -name 'barclamp-*') |sort -u
}

barclamps_in_build() {
    flat_checkout || die "Cannot get list of barclamps, must flatten build first!"
    local build bc
    build="${1:-$(get_repo_cfg 'crowbar.build')}"
    barclamp_finder "$build" '/barclamp-(.+)$'
}

barclamps_in_release() {
    # $1 = release
    release_exists "$1" || return 1
    barclamp_finder "$1" '/barclamp-(.+)$'
}

builds_in_release() {
    release_exists "$1" || return 1
    barclamp_finder "$1" "releases/[^/]+/([^/]+)/barclamp-crowbar"
}

all_barclamps() {
    local bc
    local -A barclamps
    barclamp_finder '' '/barclamp-(.+)$'
}

branches_for_release() { barclamp_finder "${1:-$(current_release)}" 'releases/.+/([^/]+)/barclamp-crowbar$'; }

all_releases() { barclamp_finder '' 'releases/(.+)/master/barclamp-crowbar$'; }

switch_barclamps_to_build() {
    # $1 = new build
    build_exists "$1" || die "Build $1 does not exist"
    for bc in $(barclamps_in_build "$1"); do
	[[ -d $CROWBAR_DIR/barclamps/$bc ]] || \
	    die "Barclamp $bc does not exist locally. Please run dev setup to clone it."
    done
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	bc=${bc##*/}
	new_branch=$(barclamp_branch_for_build "$1" "$bc")
        [[ $(in_barclamp "$bc" git symbolic-ref HEAD 2>/dev/null) = refs/heads/$new_branch || \
            $(in_barclamp "$bc" git rev-parse HEAD) = $new_branch ]] && \
            continue
	if [[ $new_branch = empty-branch ]]; then
            debug "Switching $bc to the empty branch."
	    in_barclamp "$bc" to_empty_branch
	else
            debug "Switching $bc to $new_branch"
	    in_barclamp "$bc" quiet_checkout "$new_branch" && continue
            {
                echo "$new_branch does not exist in $bc!"
                echo "You should try to fix it with a ./dev fetch followed by ./dev sync."
                exit 1
            } >&2
	fi
    done
}

# Check out the appropriate release branch for all the barclamps in a given
# release, and then check out the appropriate branch in the release.
switch_release() {
    local br bc current_branch new_base rel repo
    local -A barclamps
    new_build="$(current_build)"
    if build_exists "$1"; then
        new_build="$1"
    elif release_exists "$1"; then
        new_build="$1/${new_build##*/}"
        if ! build_exists "$new_build"; then
            echo "Release $1 does not have build $new_build, switching to $1/master instead."
            new_build="$1/master"
        fi
    elif [[ $1 ]]; then
	die "$1 is not a release or a build I can switch to!"
    fi
    crowbar_is_clean || \
	die "Crowbar repo must be clean before trying to switch releases!"
    new_branch=$(build_branch "$new_build")
    if git_managed_cache && [[ $switch_include_cache ]]; then
	if in_cache branch_exists "$new_branch"; then
	    debug "Checking out ${new_branch} in the build cache, please be patient."
	    in_cache quiet_checkout -f "$new_branch"
	fi
    fi
    switch_barclamps_to_build "$new_build"
}

checkout() {
    local br new_build rel
    rel="$(current_release)"
    new_build="$rel/$1"
    switch_barclamps_to_build "$rel/$1"
}

# Test to see of we are on the right metadata version.
dev_is_setup() {
    [[ $DEV_GITHUB_ID || $1 = setup ]] || return 1
    local thisrev
    thisrev=$(get_repo_cfg crowbar.dev.version) && \
	(( thisrev  == DEV_VERSION )) || [[ $1 = setup ]] || {
	VERBOSE=true
	debug "Crowbar repository out of sync with dev tool revision."
	debug "Please run $0 setup to update it."
	exit 1
    }
}

set -o pipefail

# Given a branch, print the first remote that branch is "owned" by.
# This assumes update_tracking_branches is keeling things up to date.
remote_for_branch() {
    if [[ ! $DEV_FROM_REMOTES ]]; then
	git config --get "branch.$1.remote"
	return $?
    fi
    local remote
    for remote in "${DEV_FROM_REMOTES[@]}"; do
	git show-ref --quiet --verify "refs/remotes/$remote/$1" || continue
	echo "$remote"
	return 0
    done
    return 1
}

# Get the URL base for the specified remote.
# The remote must have been configured via ./dev remote or ./dev setup
# for the appropriate metadata to have been populated.
remote_urlbase() {
    crowbar_remote_exists "$1" || \
	die "Remote $1 had not been configured via dev or it does not exist."
    get_repo_cfg "crowbar.remote.$1.urlbase"
}

# Test to see if a specific repository is clean.
# Ignores submodules and unchecked-in directories that are git repositories.
git_is_clean() {
    local line hpath ret=0 opt
    local stat_cmd="git status --porcelain --ignore-submodules" quiet=''
    local paths=()
    while [[ $1 ]]; do
	opt="$1"; shift
	case $opt in
	    --barclamps) stat_cmd="git status --porcelain";;
	    -q|--quiet) quiet=true;;
	    --paths)
		while [[ $1 && $1 != '-'* ]]; do
		    paths+=("$1")
		    shift
		done;;
	    *) die "Unknown option $opt passed to git_is_clean.";;
	esac
    done
    [[ $paths ]] && stat_cmd+=" -- ${paths[*]}"
    while read line; do
	case $line in
	    # Untracked file.  Ignore it if it is also a git repo,
	    # complain otherwise.
	    '??'*) hpath=${line%% ->*}
		hpath=${hpath#* }
		[[ -d $PWD/$hpath.git || -f $PWD/$hpath.git ]] && continue
		ret=1; break;;
	    '') continue;;
	    *) ret=1; break;;
	esac
    done < <($stat_cmd)
    [[ $ret = 0 ]] && return
    [[ $quiet ]] || {
	echo "$PWD:"
	git status -- "${paths[@]}"
    }
    [[ $IGNORE_CLEAN ]] && return 0
    return 1
}

# Stupid wrapper around git push for debugging.
git_push() {
    if [[ $DEBUG = true ]]; then
	echo "would have done git push $@"
	return
    fi
    git push "$@"
}

# Test to see if a barclamp is clean.
barclamp_is_clean() {
    local bc="$1"; shift
    in_barclamp "$bc" git_is_clean "$@"
}

# Test to see if all our barclamps are clean.
barclamps_are_clean() {
    local bc res=0
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	is_barclamp "${bc##*/}" || continue
	in_barclamp "${bc##*/}" git_is_clean "$@" || res=1
    done
    return $res
}

# Test to see if all the Crowbar repositories are clean.
crowbar_is_clean() {
    local res=0
    barclamps_are_clean "$@" && in_repo git_is_clean "$@" && return 0
    echo "Your crowbar repositories are not clean."
    echo "Please review the git status output above, and add and commit/stash as needed."
    return 1
}


test_remote() { git ls-remote "$1" "refs/heads/master" &> /dev/null; }

# Perform an initial clone of a barclamp.  Takes care to ensure that
# the origin remote is set appropriatly.
clone_barclamp() {
    # $1 = name of the barclamp
    local repo remote build head urlbase
    [[ -d $CROWBAR_DIR/barclamps/$1/.git || \
	-f $CROWBAR_DIR/barclamps/$1/.git ]] && return 0
    repo="barclamp-$1"
    for remote in $(sorted_remotes); do
	urlbase="$(remote_urlbase "$remote")"
	test_remote "$urlbase/$repo.git" || continue
	if [[ $urlbase =~ $github_re ]] && remote_available personal; then
	    # test to see if we need to fork this barclamp at Github
	    github_repo_exists "$repo" || github_fork "$remote" "$repo" || \
		die "Unable to fork $repo on Github. clone_barclamp giving up."
	fi
	in_repo git clone "$urlbase/$repo.git" "barclamps/$1" || {
	    rm -rf "$CROWBAR_DIR/barclamps/$1"
	    die "Unable to clone barclamp $bc from $urlbase/$repo.git"
	}
	sync_barclamp_remotes "$1"
	in_barclamp "$1" git remote rm origin
	in_barclamp "$1" update_tracking_branches
	in_barclamp "$1" quiet_checkout master
	return
    done
    die "Asked to clone $1, but could not!"
}

# Check out a branch, but be quiet about it unless something goes wrong.
quiet_checkout() {
    local res=''
    res=$(git checkout -q "$@" 2>&1) && return
    echo "$res" >&2
    return 1
}

clear_tracking_info() {
    local line k v branch_re='^branch\..*\.(merge|remote)$'
    while read line; do
	k=${line%%=*}
	v=${line#*=}
	[[ $k =~ $branch_re ]] || continue
	git config --unset "$k"
    done < <(git config --list)
}

# Update tracking branches for all remotes in a specific repo.
# Expects to be called within a specific repository
update_tracking_branches() {
    # Create tracking branches for any branches from this remote
    # that do not already exist.
    local remote
    clear_tracking_info
    while read remote; do
	git_remote_exists "$remote" || continue
	while read p br; do
	    [[ $br = refs/remotes/$remote* ]] || continue
	    br=${br#refs/remotes/$remote/}
	    [[ $br = HEAD ]] && continue
	    [[ $br = personal/* ]] && continue
	    [[ $br = pull-req* ]] && continue
	    branch_exists "$br" || git branch "$br" "$remote/$br" >&/dev/null
	    git_config_has "branch.$br.remote" || \
		git config "branch.$br.remote" "$remote"
	    git_config_has "branch.$br.merge" || \
		git config "branch.$br.merge" "refs/heads/$br"
	done < <(git show-ref)
    done < <(sorted_remotes)
}

update_all_tracking_branches() {
    local bc
    debug "Updating tracking branch references"
    in_repo update_tracking_branches
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc/.git || -f $bc/.git ]] || continue
	(cd "$bc"; update_tracking_branches)
    done
}

scrub_merged_pull_requests() {
    dev_is_setup || return 0
    # $@ = branches to test for mergedness
    local br ref pull_req
    local -A to_remove pull_reqs heads
    remote_available personal || return
    while read ref br; do
	case $br in
	    refs/heads/*)
		ref=${br#refs/heads/}
		heads[${ref//\//-}]+="$br ";;
	    refs/remotes/personal/pull-req-*)
		ref=${br#refs/remotes/personal/pull-req-}
		ref=${ref#heads-}
		ref=${ref%-*}
		ref=${ref%-0}
		pull_reqs["$br"]="$ref";;
	esac
    done < <(git show-ref)
    [[ ${pull_reqs[*]} ]] || return 0
    for pull_req in "${!pull_reqs[@]}"; do
	ref="${pull_reqs[$pull_req]}"
	[[ ${heads[$ref]} ]] || continue
	for br in ${heads["$ref"]}; do
	    branches_synced . "$br" "$pull_req" || \
		[[ $1 = '--all' ]] || continue
	    to_remove["${pull_req#refs/remotes/personal/}"]="true"
	    continue 2
	done
    done
    [[ ${!to_remove[*]} ]] || return
    git_push --delete personal "${!to_remove[@]}"
    git remote prune personal
}

# Fetch (but do not merge) updates from all our remotes, in both the
# main Crowbar repository and the barclamps.
fetch_all() {
    local remote remotes=() barclamp bc bc_remote branches=()
    local -A fetched_barclamps
    if [[ $@ || $DEV_FROM_REMOTES ]]; then
	[[ $1 ]] && remotes+=("$@")
	[[ $DEV_FROM_REMOTES ]] && remotes+=("${DEV_FROM_REMOTES[@]}")
    else
	remotes=($(sorted_remotes))
    fi
    for remote in "${remotes[@]}"; do
	crowbar_remote_exists "$remote" && remote_available "$remote" || continue
	debug "Fetching from remote $remote:"
	debug "    Crowbar"
	in_repo git fetch -q "$remote" || continue
	for bc in "$CROWBAR_DIR/barclamps/"*; do
	    [[ -d $bc/.git || -f $bc/.git ]] || continue
	    bc=${bc##*/}
	    in_barclamp "${bc}" git_remote_exists "$remote" || continue
	    debug "    Barclamp $bc"
	    in_barclamp "$bc" git fetch -q "$remote" || \
		echo "Could not fetch updates for $barclamp from remote $remote" >&2
	done
	[[ $remote = personal ]] && scrub_merged_pulls || :
    done
    update_all_tracking_branches
}

scrub_merged_pulls() {
    in_repo scrub_merged_pull_requests "$@"
    for barclamp in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $barclamp ]] || continue
	in_barclamp "${barclamp##*/}" scrub_merged_pull_requests "$@"
    done
}

# Helper function for calling curl to talk to github.
curl_and_res() {
    local __r="$(curl -n "$@" 2>/dev/null)"
    case $? in
	0) printf '%s' "$__r";;
	7) echo "Unable to contact Github, please try again later." >&2
	    return 1;;
	22) return 1;;
	*) echo "Curl reported error ${?}!." >&2
	    return 1;;
    esac
}

github_repo_exists() {
    # $1 = repo to check for
    # $2 = user to check for it in.  Defaults to $DEV_GITHUB_ID
    local repo=$1 user=${2-$DEV_GITHUB_ID}
    curl_and_res -f -X GET "https://api.github.com/repos/$user/$repo" >&/dev/null
}

# Fork a repository on Github.
github_fork() {
    # $1 = user to fork from
    # $2 = repo to fork
    curl_and_res -f -X POST \
        "https://api.github.com/repos/$1/$2/forks" >&/dev/null || \
        die "Could not fork $1/$2! (your .netrc file may be missing)"
}

get_repo_name() {
    local repo
    repo="$(git_url_for_remote $(origin_remote))" || \
	repo="$(git_url_for_remote origin)" || \
	die "$PWD: Could not get the URL for the origin remote for this repo."
    repo="${repo##*:}"
    echo "${repo##*/}"
}

git_remote_exists() { git_config_has "remote.$1.url"; }
crowbar_remote_exists() { in_repo git_config_has "crowbar.remote.$1.urlbase"; }

git_url_for_remote() { git_remote_exists "$1" && git config --get "remote.$1.url"; }

add_remote() {
    # $1 = name of the remote to add.
    # $2 = base part of the repo to add.
    git_remote_exists "$1" && return 0
    local repo
    repo="$(get_repo_name)" || exit 1
    repo="$2/$repo"
    git ls-remote "$repo" refs/heads/master &>/dev/null || {
	debug "No git repo at $repo, skipping."
	return 0
    }
    git remote add "$1" "$repo"
    git fetch "$1"
    update_tracking_branches
}

rm_remote() {
    git_remote_exists "$1" && git remote rm "$1"
    update_tracking_branches
}

set_url_remote() {
    git_remote_exists "$1" || return 0
    local repo
    repo="$(get_repo_name)" || exit 1
    repo="$2/$repo"
    git ls-remote "$repo" refs/heads/master &>/dev/null || {
	debug "No git repo at $repo, skipping."
	return 0
    }
    git remote set-url "$1" "$repo"
    git fetch "$1"
    update_tracking_branches
}

sync_barclamp_remotes() {
    # $1 = barclamp to synchronize Crowbar remotes into.
    # We will ignore the origin remote.
    local remote urlbase remote_repo barclamp_repo
    while read remote urlbase; do
	barclamp_repo="$(get_repo_cfg "submodule.barclamps/$bc.url")"
	barclamp_repo="${barclamp_repo##*/}"
	barclamp_repo="${barclamp_repo##*:}"
	barclamp_repo="${barclamp_repo}"
	remote_repo=$(in_barclamp "$1" git_url_for_remote "$remote")
	[[ ${remote_repo%.git} = $urlbase/${barclamp_repo%.git} ]] && continue
	local update_tracking=true
	debug "Synchronizing remotes for barclamp $bc"
	if in_barclamp "$1" git_remote_exists "$remote"; then
	    in_barclamp "$1" set_url_remote "$remote" "$urlbase" || \
		die "Could not update remote $remote for barclamp $1 in sync_barclamp_remotes"
	else
	    in_barclamp "$1" add_remote "$remote" "$urlbase" || \
		die "Could not add new remote $remote for barclamp $1 in sync_barclamp_remotes"
	fi
    done < <(show_remote)
    if [[ $update_tracking ]]; then
	in_barclamp "$1" update_tracking_branches
    fi
}

show_remote() {
    local line remote url remote_re='^crowbar\.remote\.([^.]+)\.urlbase=(.*)$'
    while read line; do
	[[ $line =~ $remote_re ]] || continue
	remote=${BASH_REMATCH[1]}
	url=${BASH_REMATCH[2]}
	if [[ $1 && $1 = $remote ]]; then
	    echo  "$remote urlbase=$url priority=$(remote_priority $remote)"
	elif [[ ! $1 ]]; then
	    echo "$remote $url"
	fi
    done < <(in_repo git config --list |grep '^crowbar\.remote\.')
}

sorted_remotes() {
    local __remotes=() remote u
    while read remote u; do
	__remotes[$(remote_priority $remote)]+="$remote "
    done < <(show_remote)
    printf "%s\n" ${__remotes[@]}
}

remote_is_github() {
    git_remote_exists "$1" && crowbar_remote_exists "$1" || \
	return 1
    [[ $(get_repo_cfg "crowbar.remote.$1.urlbase") =~ $github_re ]]
}

remote_github_account() {
    remote_is_github "$1" || return 1
    echo "${BASH_REMATCH[1]}"
}

remote_priority() {
    # $1 = remote name
    crowbar_remote_exists "$1" || return 1
    in_repo git_config_has "crowbar.remote.$1.priority" || echo 50
    get_repo_cfg "crowbar.remote.$1.priority"
}

remote_wrapper() {
    # $1 = one of "add", "rm", "set-url", "show"
    # $2 = name of remote
    # $3 = base part of the remote URL.  Only used for add and set-url.
    local remote urlbase action bc cfgaction=()
    remote="$2"
    urlbase="$3"
    case $1 in
	add)
	    action=add_remote
	    if [[ ! $urlbase && $remote =~ $github_re ]]; then
		urlbase="$2"
		remote="${BASH_REMATCH[1]}"
	    fi
	    if crowbar_remote_exists "${remote}"; then
		die "We already have a remote for $remote."
	    fi
	    cfgaction=(in_repo git config "crowbar.remote.${remote}.urlbase" "$urlbase")
	    ;;
	rm)
	    action=rm_remote
	    if ! crowbar_remote_exists "${remote}"; then
		die "No remote named $remote to remove."
	    fi
	    local r=($(sorted_remotes))
	    (( ${#sorted_remotes[@]} == 1)) && \
		die "$1 is your last remote.  Can't remove it."
	    cfgaction=(in_repo git config --unset "crowbar.remote.${remote}.urlbase")
	    ;;
	set-url)
	    action=set_url_remote
	    if ! crowbar_remote_exists "${remote}"; then
		die "Cannot set-url for a remote your have not added."
	    fi
	    cfgaction=(in_repo git config "crowbar.remote.${remote}.urlbase" "$urlbase")
	    ;;
	show) shift;
	    show_remote "$1"
	    return;;
	sync) action=sync_barclamp_remotes;;
	priority)
	    crowbar_remote_exists "$2" || \
		die "Remote $2 must be configured before you can set its priority."
	    [[ $3 =~ [0-9]+ ]] && (($3 > 0 && $3 <= 100)) || \
		die "Priority must be a number between 1 and 100"
	    in_repo git config "crowbar.remote.$remote.priority" "$3"
	    update_all_tracking_branches
	    return;;
	''|help) die "Please pass one of add, rm, set-url, sync, priority, or show.";;
	*) die "Unknown action $1 for remote.";;
    esac
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc/.git || -f $bc/.git ]] || continue
	debug "Barclamp: ${bc##*/}"
	in_barclamp "${bc##*/}" $action "$remote" "$urlbase"
    done
    debug "Crowbar:"
    "${cfgaction[@]}"
    if [[ $action != sync_barclamp_remotes ]]; then
	in_repo $action "$remote" "$urlbase"
    fi
}

migrate_1_to_2() {
    local url=$(get_repo_cfg "remote.origin.url")
    if [[ $url =~ $github_re ]]; then
	local account="${BASH_REMATCH[1]}"
	local urlpart="https://github.com/${BASH_REMATCH[1]}"
    else
	die "Initial fork of Crowbar must come from Github!"
    fi
    remote_wrapper add "$account" "$urlpart"
    remote_wrapper priority "$account" 5
    update_all_tracking_branches
    for rb_source in "${!DEV_REMOTE_BRANCHES[@]}"; do
	rb="${DEV_REMOTE_BRANCHES[$rb_source]}"
	[[ $rb_source = origin ]] && rb_source="$account"
	if [[ ${DEV_REMOTE_SOURCES[$rb_source]} ]]; then
	    crowbar_remote_exists "$rb_source" && continue
	    remote_available "$rb_source" || continue
	    remote_wrapper add "$rb_source" "${DEV_REMOTE_SOURCES[$rb_source]}"
	fi
    done
    crowbar_remote_exists origin && remote_wrapper rm origin
    in_repo git_remote_exists origin && in_repo git remote rm origin
    for bc in "${CROWBAR_DIR}/barclamps/"*; do
	[[ -d $bc/.git || -f $bc/.git ]] || continue
	in_barclamp "${bc##*/}" git_remote_exists origin && \
	    in_barclamp "${bc##*/}" git remote rm origin
    done
    for bc in $(in_repo git config --list |grep '^crowbar.backup'); do
	in_repo git config --unset "${bc%%=*}"
    done
    unset b rb rb_source DEV_REMOTE_BRANCHES DEV_REMOTE_SOURCES
}

migrate() {
    # $1 = source revision
    # $2 = target revision
    local src_rev=${1:-0} target_rev=${2:-$DEV_VERSION} i
    if ((src_rev == 0)) && in_repo git_config_has crowbar.dev.version; then
	src_rev=$(get_repo_cfg crowbar.dev.version)
    fi
    ((src_rev == target_rev)) && return
    [[ $DEV_AVAILABLE_REMOTES ]] && {
	echo "dev setup must have access to all your configured remotes to continue."
	echo "DEV_AVAILABLE_REMOTES is set, indicating that some of your remotes are not available."
	echo "dev setup is aborting."
	exit 1
    } >&2
    ((src_rev > target_rev)) && \
	die "Cannot migrate down from $src_rev to $target_rev."
    for ((i=src_rev; i < target_rev; i++)); do
	grep -q 'function' < <(LC_ALL=C type "migrate_${i}_to_$(($i + 1))" 2>/dev/null) || continue
	"migrate_${i}_to_$(($i + 1))" || \
	    die "Migration from $src_rev to $target_rev failed at rev $i"
    done
}


# Perform initial setup.  If you make any changes to this function, take
# care to make sure it stays idempotent.
setup() {
    local p remote release br head
    local -A touched_branches barclamps
    [[ $(in_repo git symbolic-ref HEAD) = refs/heads/master ]] || \
	die "You must be on the master branch in Crowbar to run setup!"
    crowbar_is_clean || \
	die "Crowbar repo must be clean before trying to set things up!"
    # Make sure we have Github login credentials as the very first thing.
    [[ $DEV_GITHUB_ID ]] || {
	local DEV_GITHUB_PASSWD
	read -p "Enter your Github username: " DEV_GITHUB_ID
	curl_and_res -f \
	    "https://api.github.com/users/$DEV_GITHUB_ID" &>/dev/null || \
	    die "Could not verify that $DEV_GITHUB_ID is a valid Github user.."
	while [[ $p != $DEV_GITHUB_PASSWD || ! $p ]]; do
	    [[ $p ]] && echo "Passwords did not match, try again."
	    read -s -p "Enter your Github password: " DEV_GITHUB_PASSWD
	    echo
	    read -s -p "Enter your Github password again: " p
	    echo
	done
	curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
	    https://api.github.com/user &>/dev/null || {
	    echo "Unable to authenticate as Github user $DEV_GITHUB_ID." >&2
	    die "Please try again when you have Github access."
	}
	for mach in github.com api.github.com; do
	    grep -q "^$mach" "$HOME/.netrc" &>/dev/null && continue
	    printf "\nmachine %s login %s password %s\n" \
		"$mach" "$DEV_GITHUB_ID" "$DEV_GITHUB_PASSWD" >> "$HOME/.netrc"
	done
	chmod 600 "$HOME/.netrc"
	printf "DEV_GITHUB_ID=%q\n" "$DEV_GITHUB_ID" >> "$HOME/.build-crowbar.conf"
    }
    # We have a baked-in assumption that Github is our origin, and that
    # any repositories that are named the same thing as a repository from
    # $(origin_remote) is in fact a fork of a $(origin_remote) repo.
    # We should not make that assumption at some point in the future.
    migrate "$(get_repo_cfg crowbar.dev.version)" "$DEV_VERSION"
    if ! github_repo_exists crowbar; then
	echo "Creating your fork of Crowbar on Github."
	github_fork "$(origin_remote)" crowbar || \
	    die "Unable to create your fork of Crowbar."
    fi
    if ! crowbar_remote_exists "$(origin_remote)"; then
	echo "Configuring $(origin_remote) remote for Crowbar"
	remote_wrapper add "$(origin_remote)" "https://github.com/$(origin_remote)"
	in_repo git config "crowbar.remote.$(origin_remote).priority" 5
    fi
    if [[ $(origin_remote) != $DEV_GITHUB_ID ]] && \
	! crowbar_remote_exists personal; then
	echo "Adding remote for personal fork of crowbar on Github."
	remote_wrapper add personal "https://github.com/$DEV_GITHUB_ID"
	remote_wrapper priority personal 95
    fi
    in_repo git config branch.autosetupmerge true &>/dev/null
    in_repo git config crowbar.backup.method per-remote
    # Set up the rest of our upstream remotes.
    if crowbar_remote_exists personal && \
	! in_repo git_config_has "crowbar.backup.$(origin_remote).method"; then
	in_repo git config crowbar.backup.$(origin_remote).method remote
	in_repo git config crowbar.backup.$(origin_remote).remote personal
    fi
    for bc in $(all_barclamps); do
	if [[ -d $CROWBAR_DIR/barclamps/$bc/.git || \
	    -f $CROWBAR_DIR/barclamps/$bc/.git ]]; then
	    debug "Syncing remotes for $bc"
	    sync_barclamp_remotes "$bc"
	else
	    debug "Performing initial clone of barclamp $bc"
	    clone_barclamp "$bc"
	fi
    done
    in_repo git config crowbar.dev.version "$DEV_VERSION"
    flatten_crowbar
}

# Test repository $1 to see if commit $2 is in sync with $3.
# In this case, "in sync" is defined as:
#  * $2 and $3 point at the same commit, or
#  * There are no commits in the set of all commits reachable from $3 that
#    are not also reachable from $2.
branches_synced() {
    # $1 = repository to operate in
    # $2 = local branch to test
    # $3 = remote branch to test
    [[ -d $1/.git || -f $1/.git ]] || \
	die "branches_synced: $1 is not a git repo"
    [[ $VERBOSE2 ]] && echo "Checking to see if out of sync: $2 $3"
    (cd "$1"; git rev-parse --verify -q "$2" &>/dev/null) || \
	return 1
    (cd "$1"; git rev-parse --verify -q "$3" &>/dev/null) || \
	return 1
    # $2 and $3 resolve to the same commit, they are in sync.
    (cd "$1"; [[ $(git rev-parse "$2") = $(git rev-parse "$3") ]] ) && return 0
    # Test to see if there are any commits in $3 that are not
    # reachable from $2.  If there are, then the branches are not synced.
    (cd "$1"; [[ ! $(git rev-list "$2..$3") ]] ) && return 0
    return 1
}

get_backup_var() {
    local res=''
    res=
	return 1
    echo "$res"
}

# Back up any local commits that are not already present on our upstreams,
# or that have not already been backed up.
backup_repo() {
    local id bc branch remote branch_get_func branch_backup_func
    local -A branches backup_remotes
    local backup_method target_remote target_method target_prefix
    local remote_re='^refs/remotes/([^/]+)'
    while read id branch; do
	if [[ $branch = refs/heads/* ]]; then
	    # This is a local ref, see if it needs backed up.
	    branch=${branch#refs/heads/}
	    # Does this branch have a remote, and is it one that Crowbar cares about?
	    remote=$(remote_for_branch "$branch") || continue
	    crowbar_remote_exists "$remote" && remote_available "$remote" || continue
	    # If we already know what the backup remote is for this branch is based
	    # on the upstream remote for the branch is, carry on.
	    [[ ${backup_remotes[$remote]} ]] || {
		# Otherwise, firgure out whether this branch is from a remote we are backing up.
		backup_remote=$(get_repo_cfg "crowbar.backup.$remote.remote") && \
		    crowbar_remote_exists "$backup_remote" && \
		    git_remote_exists "$backup_remote" && \
		    remote_available "$backup_remote" || \
		    continue
		backup_remotes[$remote]="${backup_remote}"
	    }
	    if ! git rev-parse --verify -q \
		"refs/remotes/${backup_remotes[$remote]}/$branch" &> /dev/null || \
		[[ $(git rev-parse "refs/remotes/${backup_remotes[$remote]}/$branch") != \
		$(git rev-parse "refs/heads/${branch}") ]]; then
		# Only back up branches that either don't exist on the backup remote
		# for this branch, or that do exist but don't point at the commit we want.
		branches[${backup_remotes[$remote]}]+="$branch "
	    fi
	elif [[ $branch =~ $remote_re ]]; then
	    # This is a remote ref, see if we care about it and need to delete it.
	    remote="${BASH_REMATCH[1]}"
	    # Is this a remote we are using as a backup target?
	    is_in "$remote" "${backup_remotes[*]}" || continue
	    branch=${branch#refs/remotes/${remote}/}
	    # Skip any pull request branches.
	    [[ $branch = pull-req-* || $branch = HEAD ]] && continue
	    # Skip any branches that have a local head.
	    git show-ref --verify --quiet "refs/heads/$branch" && continue
	    # Schedule the branch for deletion.
	    branches["$remote"]+=":${branch} "
	fi
    done < <(LC_ALL=C git show-ref |sort -k2) # Sort ensures that local refs always come first.
    # Now, we know what to back up, what to ignore, and what to delete.
    # Make it so.
    for remote in "${!branches[@]}"; do
	[[ ${branches[$remote]} ]] || continue
	git_push -f "$remote" ${branches[$remote]}
    done
}

backup_everything() {
    local bc remote branches=() branch remotes=()
    local -A touched_bcs
    dev_is_setup || die "You must run dev setup before trying to back things up to Github."
    # Back up all the barclamps that are references as submodules for
    # branches that this remote is "authoritative" for.
    for bc in "$CROWBAR_DIR/barclamps/"*; do
	[[ -d $bc/.git || -f $bc/.git ]] || continue
	debug "Backing up barclamp ${bc##*/}"
	in_barclamp "${bc##*/}" backup_repo
    done
    debug "Backing up Crowbar"
    in_repo backup_repo
}

# Misnamed, this can pin a release, specific build,
# or a barclamp in a specific build.
__pin_release() {
    [[ $1 ]] || die "Must pass a release, release/build, or release/build/barclamp to pin."
    local bc build ref
    if barclamp_exists_in_build "$1"; then
        build=${1%/*} bc=${1##*/}
        ref="${2:-$(in_barclamp "$bc" git rev-parse HEAD)}"
        barclamp_branch_for_build "$build" "$bc" "$ref" || return 1
        debug "Checking out $ref in $bc"
        in_barclamp "$bc" quiet_checkout "$ref"
    elif build_exists "$1"; then
        for bc in $(barclamps_in_build "$1"); do
            __pin_release "$1/$bc" "$2" || return 1
        done
    elif release_exists "$1"; then
        for build in $(builds_in_release "$1"); do
            __pin_release "$build" "$2" || return 1
        done
    else
        echo "Don't know what $1 is!" >&2
        return 1
    fi
}

pin_release() {
    crowbar_is_clean || die "Crowbar must be clean before pinning $1"
    if __pin_release "$@"; then
        git commit -m "Pinned barclamps in $1 to ${2:-current HEAD}"
        return 0
    else
        in_repo git rm -r --cached releases/
        in_repo git checkout HEAD -- releases
        echo "Could not pin $1 to ${2:-current HEAD}, leaving things unchanged."
        return 1
    fi
}

unpin_release() {
    [[ $1 ]] || die "Must pass a release, release/build, or release/build/barclamp to unpin."
    local bc build
    if barclamp_exists_in_build "$1"; then
        build=${1%/*}
    elif build_exists "$1"; then
        build="$1"
    elif release_exists "$1"; then
        build="$1/master"
    else
        die "Don't know what $1 is!"
    fi
    pin_release "$1" "$(build_branch "$build")"
}

merge_or_rebase_from_remote() {
    # $1 = remote
    # $2 = local branch
    local remote branch rebase_temp
    remote="$1" branch="$2" rebase_temp="$branch-rebase"
    git rev-parse --verify -q "$remote/$branch" &>/dev/null || return 0
    branches_synced "." "refs/heads/$branch" "refs/remotes/$remote/$branch" && return 0
    [[ $head ]] || head=$(git symbolic-ref HEAD) || \
	head=$(git rev-parse HEAD) || die "$repo: Cannot find head commit."
    quiet_checkout "$branch" || die "$remote: Unable to checkout $branch!"
    git branch -f --no-track "$rebase_temp" "$branch"
    debug "$repo: Merging $remote/$branch into $branch"
    git merge -q "$remote/$branch" || {
	git merge --abort
	die "$repo: Unable to merge $remote/$branch into $branch, aborted"
    }
    if [[ $allow_remote_rebase = true ]] && \
	crowbar_remote_exists "$remote" && \
	[[ ! $DEV_FROM_REMOTES ]]; then
	if ! git rebase -p -q "$remote/$branch" "$rebase_temp" &>/dev/null; then
	    git rebase --abort
	    quiet_checkout "$branch"
	elif ! git diff --exit-code "$branch" "$rebase_temp"; then
	    quiet_checkout "$branch"
	else
	    debug "$repo: Rebased version of $branch is identical to merged version."
	    debug "$repo: Using the rebased version instead."
	    quiet_checkout "$branch"
	    git reset --hard "$rebase_temp"
	fi
    fi
    git branch -D "$rebase_temp" &>/dev/null
}

# Handle merges across releases.  Most of the ugliness here is around making
# sure that we don't get merge conflicts due to different barclamp submodule
# updates, which we don't care about locally.
merge_releases() {
    # $@ = releases to merge.
    local rel branch start_ref
    start_ref=$(git rev-parse HEAD)
    for rel in "$@"; do
	[[ $rel ]] || continue
	[[ $rel = $(current_release) ]] &&  continue
	release_exists "$rel" || continue
	branch=$(release_branch "$rel")
	branch_exists "$branch" || continue
	git merge -q "$branch" && continue
	git merge --abort
	{
	    echo "Merging releases $@ into $(current_release) failed."
	    echo "Dropping to a shell for you to fix up."
	    echo "If you want to abort this merge, exit the shell with 'exit 1'"
	    /bin/bash
	} || {
	    git merge --abort
	    git branch "${head#refs/heads/}" "$start_ref"
	    die "$repo: Merge of $br from $rel into $cur_rel failed."
	}
    done
}

# Merges in changes into all local branches from their upstreams.
# Assumes that upstream commits have already been fetched from the proper
# remotes by running dev fetch.
sync_repo() (
    local branch head b rel bc remote ref repo="$1"
    shift
    # $repo = dir to CD to initially.
    # Assumes that remote has already been fetched.
    cd "$repo"
    # Repo is not clean, we will refuse to merge in any case.
    git_is_clean || exit 1
    # Merge upstream branches from our remotes
    head=$(git symbolic-ref HEAD) && [[ $head = refs/heads/* ]] || \
	die "$repo: Cannot find head commit."
    while read ref branch; do
	branch=${branch#refs/heads/}
	remote="$(remote_for_branch "$branch")" || continue
	merge_or_rebase_from_remote "$remote" "$branch"
    done < <(git show-ref --heads)
    quiet_checkout "${head#refs/heads/}"
    if [[ $@ ]]; then
	merge_releases "$@"
    fi
    return 0
)

# Merge all changes from our upstreams for all barclamps and the main Crowbar
# repository, and then update the branches for the current release according
# to the branch structure defined in DEV_BRANCHES.
sync_everything() {
    local unsynced_barclamps=()
    local b u head res=0 ref branch rel allow_remote_rebase=true
    crowbar_is_clean || exit 1
    # Do barclamps first.
    for b in "$CROWBAR_DIR/barclamps/"*; do
	debug "Syncing ${b##*/}"
	if ! sync_repo "$CROWBAR_DIR/barclamps/${b##*/}" "$@"; then
	    unsynced_barclamps+=("${b##*/}")
	    continue
	fi
    done
    # Finished with barclamps, now for crowbar.
    allow_remote_rebase=false
    debug "Syncing crowbar"
    sync_repo "$CROWBAR_DIR" "$@" || \
	die "Could not sync Crowbar with origin branches"
    if [[ $unsynced_barclamps ]]; then
	echo "Unable to sync origin with current master in:" >&2
	echo "  ${unsynced_barclamps[*]}"
	res=1
    fi
    [[ $res = 0 ]] && return 0
    echo
    echo "Please fix things up and rerun sync."
    return 1
}

dev_short_help() {
    cat <<EOF
$0: Development helper for Crowbar

setup:              Sets up a Crowbar checkout for use with dev.
is_clean:           Test to see if all work is committed.
fetch:              Fetch updates from configured upstream repositories.
remote:             Manage remotes across all Crowbar repositories.
backup:             Back up changes without merging them into upstream.
sync:               Synchronize fetched updates with the local repos.
push:               Unconditionally push a branch to your personal repos.
pull-requests-prep: Prepare to issue pull requests.
pull-requests-gen:  Issue pull requests.
release:            Show the current release or feature you are on.
releases:           Show all releases and features in your local repos.
branches:           Show the branches in the current release.
switch:             Switch to a different release.
checkout:           Check out a branch in the current release.
build:              build Crowbar.
cut_release:        Cut a new release from the current one.
new-feature:        Create a new feature bundle from the current release.
erase-feature:      Forget about branches for a feature you are not working on.
find-parent:        Find the closest parent of a release or feature.
reset-release:      Resets a release to upstream or your last backup.
pin:                Pin a release, build, or barclamp in a build to a specific rev
unpin:              Unpin a release, build, or barclamp in a build.
scrub-merged-pulls: Scrub merged pull request branches.
setup-unit-tests:   Sets up unit test environment
reload-unit-tests:  Reload the data for the unit test environment
run-unit-tests:     Run unit and BDD tests
clear-unit-tests:   Remove unit test environment

For more detailed help, use the "help" command or read README.dev-and-workflow.
EOF
    }

dev_help () {
    less <<EOF
$0: Development helper for Crowbar.

Command line options:

  setup -- Sets up your local Crowbar repositories for working with the
	   new Github regime.  This command will prompt for your Github
	   login information, make sure you have local copies of all the
	   barclamp repos that Crowbar references checked out, create personal
	   forks of all the crowbar repos from the $(origin_remote) account on
	   github, and create the appropriate remotes needed for day-to-day
	   operation.

  is_clean -- Check to see if the barclamps have everything committed
	      with no untracked files, and check to see if the main
	      Crowbar repository is clean while ignoring submodule references.

  fetch -- Fetch all changes from all of the configured Crowbar repositories.
	   Does not try to merge any changes into your local repository.
	   You can run a fetch at any time without disturbing your working
	   code, provided you have network connectivity.
	   If you pass the name of a remote, fetch will try to fetch changes
	   from that remote in the main Crowbar repository and in each of the
	   barclamps

  remote -- Manage remotes across all $(origin_remote) repositories.  It has the
	    following subcommands:
	    add <remote> <urlbase> : The add subcommand adds a new remote to
		the Crowbar repositories.
	    rm <remote> : The rm subcommand removes an already-existing remote
		from the Crowbar repositories.
	    set-url <remote> <urlbase> : The set-url subcommands allows you to
		give an existing remote a new URL in all the subrepositories.
	    show <remote> : The show subcommand shows remote information for
		the named remote in all the Crowbar repositories.
	    sync : Synchronize configured remotes from the main Crowbar repository
		to any cloned barclamps.
	    priority <remote> <number>: Set the priority of a remote.
		This controls how local branches bind to remote branches -- any
		local branches that have a corresponding branch in a remote will
		be configured to track the remote with the smallest priority.
		By convention, the repository you cloned from will have a
		priority of 5, the personal repositiry on Github will have a
		priority of 95, and everything else will have a priority of 50.
		You can change the priority of a remote at any time, and your
		local tracking branches will be updated to reflect the new
		remote priority list.

	   Note that <urlbase> is the URL got will use without the actual
	   repository name.  dev assumes that the new remote uses the same
	   repository name as the origin remote does, and things will fail
	   badly if this assumption is violated.
	   As an example, the urlbase for
	      https://github.com/dellcloudedge/crowbar.git is
	      https://github.com/dellcloudedge

  backup -- Push any locally committed changes in any repositories that were
	    initially forked from $(origin_remote) into your personal Github forks.
	    You can run a backup at any time without disturbing your working
	    code, provided you have network connectivity.

  sync -- Merge any changes that have been fetched into the current
	  repositories.  dev is_clean should exit without any messages before
	  running this command.  If you pass an argument to sync, it will
	  interpret that argument as a release or feature name and try to
	  merge any changes in common branches from that release.

  push -- Unconditionally push a branch (or branches) to your crowbar Github
	  fork.  Any arguments are interpreted as branch names to push, and
	  if there are no arguments it pushes the branch you are currently on.
	  Any branches pushed using this command will automatically be backed
	  up when dev backup is run as well.

  pull-requests-prep -- Fetches, Syncs, and backs up all changes, then figures
			out the set of barclamps and crowbar branches that
			need to have pull requests created.  The output is a
			command line that canbe copied and executed.

  pull-requests-gen -- Creates a set of pull requests with similar ids and
		       links based upon the barclamps dependency trees.  These
		       will be automatically sent to Github for processing and
		       review by the Dell review team.

  release -- Shows the current release that dev is operating on.

  releases -- Lists the releases to choose from.

  branches -- Shows the branches that are part of the specified release,
	      or the current release if no release is specified.

  switch -- Change current release to the specified release, or the current
	    release if no release name was passed.  This has the side effect
	    of making sure that all the barclamps are on the proper branch for
	    that release. dev switch will also set any barclamps that are not
	    used in the new branch to an empty branch.

  checkout -- Change branch but stays in the release context if possible.
	      Checkout will ensure that any barclamps that are ont being used
	      by the new branch are set to an empty branch.

  build -- Set up the local trees and build a crowbar ISO.  Parameters:
	   --os = operating system to stage Crowbar on to.
	   --release = Release of Crowbar to build.
	   --branch = Branch withina release of Crowbar to build
	   --exact = If present, dev will run git submodule update after
		     processing the --release and --branch options, and the
		     --no-cache-update and --no-metadata-update parameters will
		     be passed to build_crowbar.sh.
		     If not present, the submodules will be checked out to the
		     appropriate master branch for the release.
	   Any other parameters will be passed unchanged to build_crowbar.sh.
	   See README.build for more information on building Crowbar.

  cut_release -- DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING! Makes a new set
		 of branches and barclamp branches from the current release into
		 the new named release.  Must provide a unique new name.

  new-feature -- Create a new set of feature branches.  Must provide a unique
		 new name, and you must be in the development release when you
		 run this command.  Internally, features are implemented as
		 releases in the feature/ namespace, so all the other release
		 manipulation commands will work with them.

  erase-feature -- Erase feature branches created with new-feature.
		   This command is intended to be run after a feature has been
		   merged into the main devleopment stream to avoid cluttering
		   up the output of the git branch command.  It will fail if
		   the feature has not been merged into the development release.

  find-parent -- Find the parent of a release or feature based on the which
		 of the releases have the shortest merge distance from the
		 release passed to find-parent, so it is possible for more than
		 one release to be considered to be the parent. If that turns
		 out to be the case, find-parent wil ask you to disambiguate.

  reset-release -- Reset a release or feature to either the last pull from
		   upstream or your last backup.  Paremeters:
		   --release: Release to reset.  Defaults to current.
		   --target: Either "upstream" or "backup".
			     Defaults to "backup".
		   --skip-master: If set, will skip resetting the master branch
				  in the release and any barclamps that the
				  master branch pulls in.  Is automatically set
				  if --release is not specified.
		   --skip-barclamps: Skip resetting the the barclamps for the
				     release.

  pin -- Pin a release, build, or barclamp in a build to a specific git commit-ish.
         Normally, barclamps in a build are allowed to track the appropriate
         branches for a release.  Pin allows you to either force them to track a
         nonstandard branch, or lock them at a specific commit or tag.

         The first argument to pin is one of a release, a build in a release, or a
         barclamp in a release in the following formats:
         <release>
         <release>/<build>
         <release>/<build>/<barclamp>

         The second argument to pin is the branch or tag to pin the barclamps to.
         If nothing is passed, pin will pin the barclamps at their current HEAD.

  unpin -- Undoes the effect of a pin bu having barclamps track the default branch
           for the passed release.

           The first argument to unpin is the same as for pin.
           There is no second argument.

  scrub-merged-pulls -- Delete any tracking branches created as placeholders
                        for pull requests.  Without any options, this just
                        scrubs tracking branches for pull requests that have
                        already been merged.  If --all is passed as an option,
                        then all pull request tracking branches will be deleted.

  setup-unit-tests -- Sets up a unit test environment with all barclamps in /tmp/crowbar.
                      Requires sudo access to install Ubuntu packages.

  reload-unit-tests -- Reload the code and database for the units.  Does not re-bundle.

  run-unit-tests -- Run BDD and unit tests from the /tmp/crowbar environment.

  clear-unit-tests -- Removes a unit test environment in /tmp/crowbar.
			for pull requests.  Without any options, this just
			scrubs tracking branches for pull requests that have
			already been merged.  If --all is passed as an option,
			then all pull request tracking branches will be deleted.
EOF
    }

# Tests to see if the given branch in a repo needs a pull request.
branch_needs_pull_req() {
    # $1 = branch
    local upstream="$to_remote/$1"
    git rev-parse --verify -q "$upstream" &>/dev/null || return 1
    branches_synced '.' "refs/remotes/$upstream" \
	"refs/heads/$1" && return 1
    return 0
}

# Make sure everything is up to date, and then figure out what barclamps
# and branches need pull requests on Github.  Once we have that figured out,
# print out a command line that can be used by dev pull-requests-gen to
# actually generate the pull requests.
pull_requests_prep() {
    remote_available personal && remote_is_github personal || \
	die "No personal remote available at Github.  Cannot do pull requests."
    crowbar_is_clean || exit 1
    fetch_all && sync_everything || \
	die "Unable to synchronize remotes for pull requests"
    local barclamps_to_push=()
    local to_remote="$(origin_remote)"
    [[ $DEV_TO_REMOTES ]] && to_remote="$DEV_TO_REMOTES"
    remote_is_github "$to_remote" || \
	die "Cannot issue pull requests for $to_remote, it is not from github."
    local branch bc
    branch=$(release_branch "$(current_release)")
    for bc in $(barclamps_in_release $(current_release)); do
	in_barclamp "$bc" branch_needs_pull_req "$branch" || continue
	barclamps_to_push+=("$bc/$branch")
    done
    in_repo branch_needs_pull_req master && local push_master=true
    [[ ${push_master} || ${barclamps_to_push} ]] || {
	echo "Everything up to date, no pull requests are possible."
	return 0
    }
    echo "Barclamps to update: ${barclamps_to_push[*]-(none)}"
    [[ ${push_master} ]] && echo "Crowbar needs push"
    echo "Command to generate pull requests:"
    echo -n "$0 pull-requests-gen --to $to_remote"
    [[ ${push_master} ]] && \
	echo -n " --branches master"
    [[ ${barclamps_to_push[*]} ]] && \
	echo -n " --barclamps ${barclamps_to_push[*]}"
    echo
}

# Actaully generate a pull request by using make_pull_request to
# create the JSON blob that github needs, and then posting that to the
# right URL at Github.
do_pull_request() {
    # $1 = url to POST to
    # rest of args passed verbatim to make_pull_request helper.
    local posturl="$1"
    local -A res
    shift
    if [[ $DEBUG ]]; then
	make_pull_request "$@"
	return
    fi
    . <(make_pull_request "$@" | \
	curl_and_res -X POST --data @- \
	-H "Content-Type: application/vnd.github.beta.raw+json" \
	"$posturl" |parse_yml_or_json - res 2>/dev/null) || {
	echo "Pull request to $posturl with following params failed:"
	echo "$@"
	echo "Please delete the ones that succeeded and try again."
	exit 1
    }
    if [[ ${res['number']} && ${res['html_url']} ]]; then
	printf "Pull request %s created (%s)\n" \
	    "${res['number']}" "${res['html_url']}"
    else
	echo "Pull request to $posturl with following params failed:"
	echo "$@"
	echo "Please delete the ones that succeeded and try again."
	exit 1
    fi
}

# Get the diffstat from the origin branch of the branch passed,
# or print an error message if there is no origin.
diffstat_from_upstream() {
    local upstream=''
    upstream="$to_remote/$1"
    if git rev-parse --verify -q "$upstream" &>/dev/null; then
	git diff --stat "$upstream" "$1"
    else
	echo "No origin to generate diffstat"
    fi
}

git_ref() {
    # $1 = branch
    printf "%s-%s" "${1//\//-}" "$(git show-ref --hash=10 "refs/heads/$1")"
}

# Make pull requests based on the command line args passed.
# These should follow the command line arguments that
# pull_requests_prep generated.
pull_requests_gen() {
    # $@ = options to parse
    dev_is_setup || die "You must run dev setup before trying to generate pull requests."
    remote_available personal && remote_is_github personal || \
	die "No personal remote available at Github.  Cannot do pull requests."
    local -A barclamps branches barclamp_branches bc_pulls br_pulls refs
    local bc br bcr title body option bc_name head
    local prc=0 n=1
    local to_remote="$(origin_remote)"
    [[ $DEV_TO_REMOTES ]] && to_remote="$DEV_TO_REMOTES"
    local to_account="$(remote_github_account "$to_remote")" || \
	die "Cannot issue pull requests for $to_remote, it is not from github."
    body="$(mktemp /tmp/crowbar-pull-req-XXXXXXXX)"
    if [[ $DEBUG ]]; then
	title="Test"
	echo "test" >> "$body"
    else
	echo "Enter a title for this pull request series."
	echo "After you have entered a title, an editor will open, and you can"
	echo "enter anything you want for the body of the pull requests."
	read -p "Title: " title
	if [[ $EDITOR ]]; then
	    $EDITOR "$body"
	else
	    nano "$body"
	fi
    fi
    # Parse our options and validate them.
    while [[ "$1" ]]; do
	case $1 in
	    --branches)
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    br="$1"
		    shift
		    in_repo branch_exists "$br" || \
			die "$br is not a branch in Crowbar!"
		    in_repo git_remote_exists "$to_remote" || \
			die "Cannot make pull request to $to_remote, we don't know about it."
		    br_pulls["$br"]="pull-req-$(in_repo git_ref "$br")"
		done;;
	    --barclamps)
		shift
		while [[ $1 && $1 != '--'* ]]; do
		    bc="${1%%/*}"
		    br="${1#*/}"
		    [[ $bc = $br ]] && br="$(release_branch)"
		    shift
		    in_barclamp "$bc" branch_exists "$br" || \
			die "$br is not a branch in barclamp $bc!"
		    [[ $br = *master ]] || \
			die "Non-master branch for a barclamp passed.  Not valid for now."
		    in_barclamp "$bc" git_remote_exists "$to_remote" || \
			die "Cannot make pull request from barclamp $bc -- it is not present at remote $to_remote!"
		    barclamps["$bc"]="true"
		    is_in "$br" "${barclamp_branches["$bc"]}" || \
			barclamp_branches["$bc"]+=" $br"
		done;;
	    *) die "Unknown option $1 to $0 pull-requests-gen!";;
	esac
    done

    for bc in "${!barclamps[@]}"; do
	for bcb in ${barclamp_branches["$bc"]}; do
	    bc_pulls["$bc/$bcb"]="pull-req-$(in_barclamp "$bc" git_ref "$bcb")"
	done
    done
    # OK, now we know how many pull requests we have to issue.
    prc=$((${#bc_pulls[@]} + ${#br_pulls[@]}))

    # issue the pull requests for our barclamps.
    for barclamp in "${!bc_pulls[@]}"; do
	local bc=${barclamp%%/*}
	local bc_base=${barclamp#*/}
	in_barclamp "$bc" git_push personal "$bc_base:${bc_pulls[$barclamp]}"
	local bc_head="$DEV_GITHUB_ID:${bc_pulls[$barclamp]}"
	local bc_name=$(in_barclamp $bc git_url_for_remote $to_remote)
	bc_name=${bc_name##*/}
	bc_name=${bc_name##*:}
	bc_name=${bc_name%.git}
	do_pull_request \
	    "https://api.github.com/repos/$to_account/$bc_name/pulls" \
	    --title "$title [$n/$prc]" --base "$bc_base" --head "$bc_head" \
	    --body "@$body" \
	    --body "$(in_barclamp "$bc" diffstat_from_upstream "$bc_base")"
	n=$(($n + 1))
    done

    # Now, issue the requests for branches.
    # Make sure they are ordered correctly.
    for br in "${!br_pulls[@]}"; do
	in_repo git_push personal "${br}:${br_pulls[$br]}"
	local br_head="$DEV_GITHUB_ID:${br_pulls[$br]}"
	do_pull_request \
	    "https://api.github.com/repos/$to_account/crowbar/pulls" \
	    --title "$title [$n/$prc]" --base "$br" --head "$br_head" \
	    --body "@$body" --body "$(in_repo diffstat_from_upstream "$br")"
	n=$(($n + 1))
    done
    rm -f "$body"
}

# Unconditionally push either the current branch or the branches
# passed on the command line to the personal remote.
push_branches() {
    # $@ = Local branches to push
    dev_is_setup || die "You must run dev setup before pushing branches to Github."
    remote_available personal && remote_is_github personal || \
	die "No personal remote available at Github.  Cannot do pull requests."
    local branches=("$@") br btp=()
    [[ $branches ]] || br=($(in_repo git symbolic-ref HEAD)) || \
	die "Main Crowbar repo is not on a branch we can push!"
    [[ $br ]] && branches=("${br#refs/heads/}")
    for br in "${branches[@]}"; do
	if in_repo git rev-parse --verify -q "$br" &>/dev/null; then
	    btp+=("$br")
	else
	    echo "$br is not a branch I can push!"
	fi
    done
    echo "Pushing ${btp[*]} to your Github fork of Crowbar."
    in_repo git_push personal "${btp[@]}"
}

# Show the releases that either the local repo or the origin repo knows about.
show_releases() { all_releases; }

# Given a build, give us the branch the barclamps will use.
build_branch() {
    # $1 = build
    case $1 in
	development/*) echo "master" ;;
	stable/*) echo "stable/${1%/*}/master";;
	feature/*/*) echo "${1%/*}/master";;
	*) echo "release/${1%/*}/master";;
    esac
}

release_branch() { build_branch "${1:-$(current_release)}/master"; }

barclamp_branch_for_build() {
    # $1 = build
    # $2 = barclamp
    # $3 = (optional) ref to pin the barclamp at.
    local bcfile="$CROWBAR_DIR/releases/$1/barclamp-$2"
    if [[ ! $3 ]]; then
        [[ -f $bcfile ]] && cat "$bcfile" || echo "empty-branch"
        return 0
    fi
    [[ -f $bcfile ]] && \
        in_barclamp "$2" git rev-parse --verify --quiet "$3" &>/dev/null || return 1
    echo "$3" > "$bcfile"
    git add "$bcfile"
}

# Given a release, find the "best" parent release.  This will only
# be called if we don't already have metadata recorded for the
# parent relationship of this release.
find_best_parent() {
    # $1 = release to find the "best" parent of.
    #      If empty, use the release we are currently on.
    local br distance best_distance ref candidate merge_base release
    local best_candidates=()
    if [[ $1 ]]; then
	release_exists "$1" || \
	    die "find_best_parents: $1 is not a release"
	release="$1"
    else
	release="$(current_release)"
    fi
    if [[ $CROWBAR_DIR/releases/$release/parent ]]; then
	cat "$CROWBAR_DIR/releases/$release/parent"
	return 0
    elif in_repo git_config_has "crowbar.releases.$1.parent"; then
	get_repo_cfg "crowbar.releases.$1.parent" | \
	    tee "$CROWBAR_DIR/releases/$release/parent"
	in_repo git commit -m "Adding parent for $release" "releases/$release/parent"
	return 0
    elif [[ $release != feature/* ]]; then
	echo development
	return 0
    fi
    VERBOSE=true
    debug "More than one good candidate for a parent of $release found."
    debug "Please pick the one you want:"
    select candidate in $(all_releases) "None of the above"; do
	case $candidate in
	    'None of the above') die "Aborting.";;
	    '') continue;;
	    *) break;;
	esac
    done
    echo "$candidate" > "$CROWBAR_DIR/releases/$release/parent"
    in_repo git commit -m "Adding parent for $release" "releases/$release/parent"
}

# Create a new release branch structure based on the current state of the
# Crowbar repositories.
cut_release() {
    local new_branch bc

    [[ $1 ]] || die "cut_release: Please specify a name for the new release"

    # Test to see if release exists.
    release_exists "$1" && die "cut_release: Name already exists"

    new_branch="$(release_branch $1)"
    crowbar_is_clean || \
	die "Crowbar repo must be clean before trying to cut a release!"

    mkdir -p "$CROWBAR_DIR/releases/$1"
    cp -a "$CROWBAR_DIR/releases/$(current_release)/." \
	"$CROWBAR_DIR/releases/$1/."
    while read bc; do
	echo "$new_branch" > "$bc"
    done < <(find "$CROWBAR_DIR/releases/$1" -name 'barclamp-*')
    [[ $1 = feature/* ]] && \
	echo "$(current_release)" > "$CROWBAR_DIR/releases/$1/parent"
    in_repo git add "releases/$1"
    in_repo git commit -m "Added metadata for new release $1"

    for bc in $(barclamps_in_release "$1"); do
	in_barclamp "$b" git branch -f --no-track "$new_branch" HEAD
    done
    if git_managed_cache && ! branch_exists "$new_branch"; then
	if in_cache branch_exists "$(release_branch)"; then
	    in_cache git branch "$new_branch" "$(release_branch)"
	else
	    in_cache git branch "$new_branch" master
	fi
    fi
}

cut_feature() {
    [[ $1 ]] || die "Please give your new feature a name!"
    cut_release "feature/$1"
}

erase_release() {
    # $1 = release refix
    local b  branch parent parent_branch
    [[ $1 = development ]] && die "Cannot erase the development release."
    release_exists "$1" || die "$1 is not a release we can erase!"
    branch="$(branch_prefix "$1")"
    parent=$(find_best_parent "$1")
    parent_branch=$(release_branch "$parent")
    parent_barclamps="$(barclamps_in_release "$parent")"
    for b in $(barclamps_in_release "$1"); do
	is_in "$b" "${parent_barclamps}" && \
	    in_barclamp "$b" branches_synced . "$parent_branch" "$branch" && \
	    continue
	printf "$1 is not merged into $parent.  Really erase? (y/n): " >&2
	read -n 1
	[[ $REPLY != 'y' ]] && exit
	break
    done
    #    die "$1 is not merged into the development release, refusing to erase."
    for b in $(barclamps_in_release "$1"); do
	in_barclamp "$b" git branch -D "$branch"
    done
    in_repo git rm -rf "releases/$1"
    in_repo git commit -m "Erasing release $1"
}

build_crowbar() {
    local build_args=() b c target_os target_build target_release target_branch exact
    local switch_include_cache=true
    target_release=$(current_release)
    target_branch=$(current_build)
    target_branch=${target_branch##*/}
    crowbar_is_clean || exit 1
    while [[ $1 ]]; do
	case $1 in
	    --os) shift; target_os="$1";;
	    --release) shift; target_release="$1";;
	    --branch) shift; target_branch="$1";;
	    --exact) exact=true;;
	    *) build_args+=($1);;
	esac
	shift
    done
    [[ $target_os ]] || \
	die "Cannot build Crowbar, need to know what OS to stage it on!"
    update_all_tracking_branches
    build_args+=("--skip-lock")
    switch_release "${target_release}" || \
	die "Could not switch to $target_release for build!"
    checkout "$target_branch"
    if [[ $exact ]]; then
	die "Exact builds are not implemented right now."
    fi
    with_build_lock exec "$CROWBAR_DIR/build_crowbar.sh" \
	"$target_os" "${build_args[@]}"
}

reset_branch() {
    # $1 = branch to reset
    # $2 = target to reset it to.
    if [[ $(git symbolic-ref HEAD) = refs/heads/$1 ]]; then
	git reset --hard "$2"
    else
	git branch -f --no-track "$1" "$2"
    fi
}

reset_release() {
    crowbar_is_clean || exit 1
    local target_release=$(current_release) target=backup
    local -A barclamp_targets
    while [[ $1 ]]; do
	case $1 in
	    --release) shift; target_release="$1";;
	    --target) shift; target="$1";;
	    *) die "Unknown option $1 passed to reset-release";;
	esac
	shift
    done
    release_exists "$target_release" || \
	die "Release $target_release does not exist, cannot reset."
    if [[ $target = backup ]]; then
	remote_available personal && remote_is_github personal || \
	    die "No personal remote available at Github.  Cannot restore from backup."
    fi
    target_branch=$(release_branch $target_release)
    for bc in $(barclamps_for_release "$target_release"); do
	[[ -d $CROWBAR_DIR/barclamps/$bc/.git || \
	    -f $CROWBAR_DIR/barclamps/$bc/.git ]] || continue
	in_barclamp "$bc" branch_exists "$target_branch" || continue
	case $target in
	    upstream) barclamp_targets[$bc]="$(in_barclamp "$bc" remote_for_branch "$target_branch")/$target_branch" || \
		die "No tracking branch for $br in $bc, cannot restore from backup.";;
	    backup) barclamp_targets[$bc]+="personal/$target_branch";;
	    *) die "Don't know how to reset barclamp $bc to $target_method";;
	esac
	if ! in_barclamp "$bc" git rev-parse --quiet --verify \
	    "${barclamp_targets[$bc]}" &>/dev/null; then
	    if [[ $target = backup ]]; then
		debug "${barclamps[$bc]} in $bc has never been backed up, skipping."
		unset barclamps_targets[$bc]
	    elif [[ $target = upstream ]]; then
		debug "Cannot reset barclamp $bc to ${barclamp_targets[$bc]}"
		unset barclamps_targets[$bc]
	    fi
	fi
    done
    for bc in "${!barclamp_targets[@]}"; do
	in_barclamp "$bc" \
	    reset_branch "$target_branch" "${barclamp_targets[$bc]}"
    done
}

flatten_crowbar() {
    local r bc br rel rel_parent rel_dir gmode gtype gsha gpath build
    local br_re='^refs/(heads|remotes/[^/]+)/(.*)$'
    local bc_url_re='^submodule\.(.+)\.url=.+/([^/]+)$'
    local -A remotes
    if [[ ! $1 ]]; then
        remotes[$(origin_remote)]=true
    else
        for r in "$@"; do
            crowbar_remote_exists "$r" || \
                die "Cannot flatten repo information for remote $r"
            remotes[$r]=true
        done
    fi
    crowbar_is_clean && \
	[[ $(in_repo git symbolic-ref HEAD) = refs/heads/master ]] || \
	die "You must be on master to flatten the hierarchy!"
    while read sha ref; do
        # Special case handling for tags.
        # We make releases for them, and have their barclamp markers point to
        # exact commits.
        if [[ $ref = refs/tags/* && ! ( $ref =~ jenkins ) ]]; then
            br="${ref#refs/tags/}"
            build="${br}/master"
        elif [[ $ref =~ $br_re ]]; then
            [[ ${BASH_REMATCH[1]} = remotes/* && \
                ! ${remotes[${BASH_REMATCH[1]#remotes/}]} ]] && \
                continue
            br="${BASH_REMATCH[2]}"
            [[ ${DEV_BRANCHES[${br##*/}]} ]] || continue
            if [[ $br = ${br##*/} ]]; then
                build="development/$br"
            elif [[ $br = release/* ]]; then
                build="${br#release/}"
            elif [[ $br = feature/* ]]; then
                build=$br
            else
                continue
            fi
        else
            continue
        fi
        build_exists "$build" && continue
	rel=${build%/*}
	build_dir="$CROWBAR_DIR/.releases/$build"
        [[ -d $build_dir ]] && continue
        # If the ref we are looking at has already been flattened,skip it.
        [[ $(in_repo git ls-tree "$ref" releases) ]] && continue
        # If this branch does not have a .gitmodules, we don't care about it.
        [[ $(in_repo git ls-tree "$ref" .gitmodules) ]] || continue
        debug "Flattening $br into $build"
	mkdir -p "$build_dir"
        # This is an evil, evil hack caused by some inconsistently named
        # barclamp repos. This finds the appropriate .gitmodules for a given
        # branch, reads and parses it as a git config file, and figures out
        # what the real barclamp name is (based on the repo name).
        # All that without touching the working tree.
        read gmode gtype gsha gpath < <(in_repo git ls-tree "$ref" .gitmodules)
        local -A barclamps
        while read line; do
            [[ $line =~ $bc_url_re ]] || continue
            barclamps["${BASH_REMATCH[1]}"]="${BASH_REMATCH[2]%.git}"
        done < <(git config --list --file <(in_repo git cat-file blob "$gsha") |sort -k 3 -t .)
        for bc in "${!barclamps[@]}"; do
            if [[ $ref = refs/tags/* ]]; then
                read gmode gtype gsha gpath < <(in_repo git ls-tree "$ref" "$bc")
                [[ $gmode = 160000 && $gtype = commit ]] || \
                    die "Cannot happen in flatten_crowbar. Something Wicked happened to your repos."
                echo "$gsha" > "$build_dir/${barclamps[$bc]}"
            else
                echo "$(build_branch "$build")" >"$build_dir/${barclamps[$bc]}"
            fi
        done
        unset barclamps
	# If there are any json config files in the branch. grab them
	while read gmode gtype gsha gpath; do
	    [[ $gtype = blob && $gpath = *.json ]] || continue
	    (cd "$build_dir"; git cat-file blob "$gsha" >"$gpath")
	done < <(in_repo git ls-tree "$ref")
    done < <(git show-ref)
    [[ -d $CROWBAR_DIR/.releases ]] || return 0
    mkdir -p "$CROWBAR_DIR/releases/"
    cp -a "$CROWBAR_DIR/.releases/." "$CROWBAR_DIR/releases/."
    rm -rf "$CROWBAR_DIR/.releases"
    in_repo git add releases
    in_repo git config 'crowbar.build' 'development/master'
    in_repo git commit -m "Added flattened Crowbar metadata."
}

setup_unit_tests() {
  rm -rf /tmp/crowbar
  mkdir /tmp/crowbar
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  mkdir -p /tmp/crowbar/barclamps/templates
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  cp -r barclamps/*/chef/data_bags/crowbar/*.json /tmp/crowbar/barclamps/templates
  for i in barclamps/*/crowbar.yml; do
    cp "$i" "/tmp/crowbar/barclamps/`basename $(dirname $i)`.yml"
  done

  cd /tmp/crowbar
  BUNDLE="bundle"
  type bundle 2>/dev/null >/dev/null || BUNDLE="/var/lib/gems/1.8/bin/bundle"
  type $BUNDLE || echo "MUST HAVE BUNDLER"
  sed -ie 's/^source .*/source "http:\/\/rubygems.org"/' "Gemfile"
  $BUNDLE
  cd ..

  cd /tmp/crowbar/BDD
  sudo /tmp/crowbar/BDD/linux_install.sh
  ./linux_compile.sh
  cd -
}

reload_unit_tests() {
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  mkdir -p /tmp/crowbar/barclamps/templates
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  cp -r barclamps/*/chef/data_bags/crowbar/*.json /tmp/crowbar/barclamps/templates
  for i in barclamps/*/crowbar.yml; do
    cp "$i" "/tmp/crowbar/barclamps/`basename $(dirname $i)`.yml"
  done

  cd /tmp/crowbar
  RAKE="rake"
  type rake 2>/dev/null >/dev/null || RAKE="/var/lib/gems/1.8/bin/rake"
  type $RAKE || echo "MUST HAVE RAKE"
  $RAKE db:drop
  $RAKE db:migrate
  $RAKE db:fixtures:dump
  cd -
 
  cd /tmp/crowbar/BDD
  ./linux_compile.sh
  sed -ie 's/192.168.124.10/127.0.0.1/' "crowbar.config"
  cd -
}

run_unit_tests() {
  # Run unit tests
  cd /tmp/crowbar
  RAKE="rake"
  type rake 2>/dev/null >/dev/null || RAKE="/var/lib/gems/1.8/bin/rake"
  type $RAKE || echo "MUST HAVE RAKE"
  $RAKE test:units
  cd -

  # Run BDD tests
  cd /tmp/crowbar/BDD
  ./linux_run.sh
  cd -
}

clear_unit_tests() {
  rm -rf /tmp/crowbar
}

in_repo origin_remote &>/dev/null || \
    [[ $1 = setup ]] || \
    die "Unable to find origin account, please run setup!"

# Handle some global option parsing.
# This is mainly for --from and --to handling. 
parse_opts_and_go() {
    local genargs=()
    while (( $# > 0)); do
	case $1 in
	    --from) shift
		in_repo git_remote_exists "$1" || \
		    die "You must pass a configured remote for --from."
		[[ ${DEV_FROM_REMOTES} ]] || DEV_FROM_REMOTES=()
		DEV_FROM_REMOTES+=("$1");;
	    --to) shift
		in_repo git_remote_exists "$1" || \
		    die "You must pass a configured remote for --to."
		[[ ${DEV_TO_REMOTES} ]] || DEV_TO_REMOTES=()
		DEV_TO_REMOTES+=("$1");;
	    *) genargs+=("$1");;
	esac
	shift
    done
    set -- "${genargs[@]}"
    case "$1" in
        is_clean) shift; crowbar_is_clean "$@";;
        fetch) shift; fetch_all "$@";;
        sync) shift; sync_everything "$@";;
        setup) setup;;
        backup) shift; backup_everything "$@";;
        push) shift; push_branches "$@";;
        pull-requests-prep) pull_requests_prep;;
        pull-requests-gen) shift; pull_requests_gen "$@";;
        help) dev_help;;
        release) current_release;;
        releases) show_releases;;
        cut_release) shift; cut_release "$@";;
        new-feature) shift; cut_feature "$1";;
        switch) shift; switch_release "$@";;
        branches) shift; branches_for_release "$@";;
        flatten) shift; flatten_crowbar "$@";;
        checkout) shift; checkout "$@";;
        build) shift; build_crowbar "$@";;
        remote) shift; remote_wrapper "$@";;
        erase-feature) shift; erase_release "feature/$1";;
        find-parent) shift; find_best_parent "$@";;
        reset-release) shift; reset_release "$@";;
        scrub-merged-pulls) shift; scrub_merged_pulls "$@";;
        pin) shift; pin_release "$@";;
        unpin) shift; unpin_release "$@";;
        setup-unit-tests) setup_unit_tests;;
        reload-unit-tests) reload_unit_tests;;
        run-unit-tests) run_unit_tests;;
        clear-unit-tests) clear_unit_tests;;
        create-barclamp) shift
            [[ -d $CROWBAR_DIR/barclamps/$1 ]] || \
                die "Barclamp $1 already exists"
            "$CROWBAR_DIR/extra/barclamp_create.rb" "$@" || exit 1
            (   cd "$CROWBAR_DIR/barclamps/$1"
                git init .
                git add .
                git commit -m "Initial commit"
            );;
        *) dev_short_help; exit 1;;
    esac
}

parse_opts_and_go "$@"

