#!/bin/bash

export LANG="C"
export LC_ALL="C"

GEM_RE='([^0-9].*)-([0-9].*)'

readonly currdir="$PWD"
export PATH="$PATH:/sbin:/usr/sbin:/usr/local/sbin"
declare -A DEV_BRANCHES DEV_REMOTE_SOURCES DEV_REMOTE_BRANCHES DEV_ORIGIN_TYPES
declare -a DEV_REMOTES DEV_ALL_REMOTES
declare -A __AVAILABLE_REMOTES
# The generation of the dev tool this is.
readonly DEV_VERSION=2

# The key -> value mapping in DEV_BRANCHES defines child -> parent relations
# between branches.  A branch is considered a root branch if it has itself
# as a parent.
DEV_BRANCHES["master"]="master"
DEV_BRANCHES["openstack-os-build"]="master"
DEV_BRANCHES["hadoop-os-build"]="master"
DEV_BRANCHES["cloudera-os-build"]="master"
github_re='^https?://.*github\.com/([^/]+)'

# DEV_REMOTE_BRANCHES defines what branches in the main Crowbar repository
# should be pulled and synced with what remotes.
# Barclamps do care about remote branches.
DEV_REMOTE_BRANCHES["origin"]="master openstack-os-build hadoop-os-build cloudera-os-build"

# Source our config file if we have one
[[ -f $HOME/.build-crowbar.conf ]] && \
    . "$HOME/.build-crowbar.conf"

# Look for a local one.
[[ -f build-crowbar.conf ]] && \
    . "build-crowbar.conf"

# Location of the Crowbar checkout we are building from.
[[ $CROWBAR_DIR ]] || CROWBAR_DIR="${0%/*}"
[[ $CROWBAR_DIR = /* ]] || CROWBAR_DIR="$currdir/$CROWBAR_DIR"
[[ -f $CROWBAR_DIR/build_crowbar.sh && -d $CROWBAR_DIR/.git ]] || \
    die "$CROWBAR_DIR is not a git checkout of Crowbar!"
export CROWBAR_DIR

. "$CROWBAR_DIR/build_lib.sh" || exit 1
trap - 0 INT QUIT TERM

which gem &>/dev/null || \
    die "Rubygems not installed, and some of our helpers need a JSON gem."

gem list -i json &>/dev/null || \
    die "JSON gem not installed.  Please install it with gem install json."


get_repo_cfg() { in_repo git config --get "$1"; }
git_config_has() { git config --get "$1" &>/dev/null; }

remote_available() {
    local r urlbase url_re='^(https?|ssh|git)://([^/]+)'
    local -A remote_hash
    [[ $DEV_AVAILABLE_REMOTES ]] || return 0
    if [[ ${__AVAILABLE_REMOTES[$1]} ]]; then
        [[ ${__AVAILABLE_REMOTES[$1]} = true ]]
        return $?
    fi
    for r in ${DEV_AVAILABLE_REMOTES//origin/$(origin_remote)}; do
        crowbar_remote_exists "$r" || \
            die "Unknown remote $r in DEV_AVAILABLE_REMOTES!"
        urlbase=$(get_repo_cfg "crowbar.remote.$r.urlbase")
        [[ $urlbase =~ $url_re ]] || continue
        remote_hash["${BASH_REMATCH[2]}"]=true
    done
    urlbase=$(get_repo_cfg "crowbar.remote.$1.urlbase")
    [[ $urlbase =~ $url_re ]] || return 1
    if [[ ${remote_hash["${BASH_REMATCH[2]}"]} ]]; then
        __AVAILABLE_REMOTES[$1]=true
        return 0
    else
        __AVAILABLE_REMOTES[$1]=false
        return 1
    fi
}

if [[ $DEV_GITHUB_PASSWD ]]; then
    debug "Migrating Github password information to $HOME/.netrc"
    for mach in github.com api.github.com; do
        grep -q "^$mach" "$HOME/.netrc" &>/dev/null && continue
        printf "\nmachine %s login %s password %s\n" \
            "$mach" "$DEV_GITHUB_ID" "$DEV_GITHUB_PASSWD" >> "$HOME/.netrc"
    done
    chmod 600 "$HOME/.netrc"
    sed -ie 's/DEV_GITHUB_PASSWD=.*//' "$HOME/.build-crowbar.conf"
    debug "Please remove your embedded login information from the remote URLS."
fi


origin_remote() {
    local r
    for r in $(sorted_remotes); do
        remote_available "$r" && git_remote_exists "$r" || continue
        echo "$r"
        return 0
    done
    return 1
}

get_barclamp_cfg() { in_barclamp "$1" git config --get "$2"; }

# Test to see of we are on the right metadata version.
dev_is_setup() {
    [[ $DEV_GITHUB_ID || $1 = setup ]] || return 1
    local thisrev
    thisrev=$(get_repo_cfg crowbar.dev.version) && \
        (( thisrev  == DEV_VERSION )) || [[ $1 = setup ]] || {
        VERBOSE=true
        debug "Crowbar repository out of sync with dev tool revision."
        debug "Please run $0 setup to update it."
        exit 1
    }
}

set -o pipefail

# Given a branch, echo all the child branches for this
# branch in the same release.
child_branches() {
    local prefix="${1%/*}/" parent=${1##*/} child br_re='^crowbar\.branch\.([^.]+)\.parent$'
    [[ ${prefix%/} = $1 ]] && prefix=''
    for child in $(get_repo_cfg "crowbar.branch.$parent.children"); do
        in_repo branch_exists "${prefix}$child" || continue
        echo "${prefix}$child"
    done
    return 0
}

# Given a branch, echo its parent in the current release.
parent_branch() {
    local prefix="${1%/*}/" parent=${1##*/} br p
    [[ ${prefix%/} = $1 ]] && prefix=''
    p="${prefix}$(get_repo_cfg "crowbar.branch.${1##*/}.parent")" && \
        [[ $p != $1 ]] || return 1
    echo "${p}"
}

# Echo all of the root branches in the current release.
root_branches() {
    local roots release b
    roots=($(get_repo_cfg "crowbar.roots")) || return 1
    case $1 in
        '') releases=("$(current_release)");;
        '--all') releases=($(show_releases));;
        *) release_exists "$1" || \
            die "root_branches: $1 is not a release!"
            releases=("$1");;
    esac
    for release in "${releases[@]}"; do
        prefix="$(branch_prefix "$release")"
        for b in "${roots[@]}"; do
            in_repo branch_exists "${prefix}$b" || continue
            echo "${prefix}$b"
        done
    done
    return 0
}

# Return a list of ordered branches based on the branch graph.
ordered_branches() {
    # $@ = branches to print all of the children of.
    [[ $@ ]] && local branches=("$@") || local branches=("$(root_branches)")
    local b children=() prefix c
    for b in "${branches[@]}"; do
        printf "%s\n" "$b"
        children=($(get_repo_cfg "crowbar.branch.${b##*/}.children"))
        [[ $children ]] || continue
        prefix="$(branch_prefix "$(release_for_branch "$b")")"
        for c in "${children[@]}"; do
            ordered_branches "${prefix}$c"
        done
    done
}

# Return an ordered list of all the branches that are a part of
# any of the releases we know about.
all_ordered_branches() { ordered_branches $(root_branches --all); }

# Return an ordered list of brancehs for a specific release.
branches_for_release() {
    local b
    for b in $(ordered_branches $(root_branches "$1")); do
        in_repo branch_exists "$b" || continue
        echo "$b"
    done
}

# Given a branch, print the first remote that branch is "owned" by.
# This assumes update_tracking_branches is keeling things up to date.
remote_for_branch() {
    if [[ ! $DEV_FROM_REMOTES ]]; then
        git config --get "branch.$1.remote"
        return $?
    fi
    local remote
    for remote in "${DEV_FROM_REMOTES[@]}"; do
        git show-ref --quiet --verify "refs/remotes/$remote/$1" || continue
        echo "$remote"
        return 0
    done
    return 1
}

# Get the URL base for the specified remote.
# The remote must have been configured via ./dev remote or ./dev setup
# for the appropriate metadata to have been populated.
remote_urlbase() {
    crowbar_remote_exists "$1" || \
        die "Remote $1 had not been configured via dev or it does not exist."
    get_repo_cfg "crowbar.remote.$1.urlbase"
}

# Check to see if a branch is present in a remote.
branch_in_remote() {
    # $1 = remote
    # $2 = branch
    git show-ref --quiet --verify -- "refs/remotes/$1/$2"
}

# Given a remote and a list of branches,
# return just the branches that are in that remote.
filter_branches_for_remote() {
    local remote="$1" b
    shift
    for b in "$@"; do
        in_repo branch_in_remote "$remote" "$b" || continue
        echo "$b"
    done
}

# Test to see if a specific repository is clean.
# Ignores submodules and unchecked-in directories that are git repositories.
git_is_clean() {
    local line hpath ret=0 opt
    local stat_cmd="git status --porcelain --ignore-submodules" quiet=''
    local paths=()
    while [[ $1 ]]; do
        opt="$1"; shift
        case $opt in
            --barclamps) stat_cmd="git status --porcelain";;
            -q|--quiet) quiet=true;;
            --paths)
                while [[ $1 && $1 != '-'* ]]; do
                    paths+=("$1")
                    shift
                done;;
            *) die "Unknown option $opt passed to git_is_clean.";;
        esac
    done
    [[ $paths ]] && stat_cmd+=" -- ${paths[*]}"
    while read line; do
        case $line in
            # Untracked file.  Ignore it if it is also a git repo,
            # complain otherwise.
            '??'*) hpath=${line%% ->*}
                   hpath=${hpath#* }
                   [[ -d $PWD/$hpath.git || -f $PWD/$hpath.git ]] && continue
                   ret=1; break;;
            '') continue;;
            *) ret=1; break;;
        esac
    done < <($stat_cmd)
    [[ $ret = 0 ]] && return
    [[ $quiet ]] || {
        echo "$PWD:"
        git status -- "${paths[@]}"
    }
    [[ $IGNORE_CLEAN ]] && return 0
    return 1
}

# Stupid wrapper around git push for debugging.
git_push() {
    if [[ $DEBUG = true ]]; then
        echo "would have done git push $@"
        return
    fi
    git push "$@"
}

# Get the current release we are working on, which is a function of
# the currently checked-out branch.
current_release() {
    local ans="$(in_repo git symbolic-ref HEAD)" || \
        die "current_release: Cannot get current branch information!"
    ans=${ans#refs/heads/}
    case $ans in
        personal/*) continue;;
        stable/*) echo "stable";;
        release/*)
            ans="${ans#release/}"
            echo "${ans%%/*}";;
        feature/*) echo "${ans%/*}";;
        *) echo "development";;
    esac
}

# Test to see if a barclamp is clean.
barclamp_is_clean() {
    local bc="$1"; shift
    in_barclamp "$bc" git_is_clean "$@"
}

# Test to see if all our barclamps are clean.
barclamps_are_clean() {
    local bc res=0
    for bc in "$CROWBAR_DIR/barclamps/"*; do
        is_barclamp "${bc##*/}" || continue
        in_barclamp "${bc##*/}" git_is_clean "$@" || res=1
    done
    return $res
}

# Test to see if all the Crowbar repositories are clean.
crowbar_is_clean() {
    local res=0
    barclamps_are_clean "$@" && in_repo git_is_clean "$@" && return 0
    echo "Your crowbar repositories are not clean."
    echo "Please review the git status output above, and add and commit/stash as needed."
    return 1
}

# Get the list of barclamps that originate from this branch.
# $1 must be a branch name, and it must be some sort of release branch.
barclamps_from_branch() {
    # If we don't have a parent branch, we are one of the roots.
    local parent=$(parent_branch "$1")
    if [[ ! $parent ]]; then
        barclamps_in_branch "$1"
        return 0
    fi
    sort <(barclamps_in_branch "$1") <(barclamps_in_branch "$parent") |uniq -u
}

# Perform an initial clone of a barclamp.  Takes care to ensure that
# the origin remote is set appropriatly.
clone_barclamp() {
    # $1 = name of the barclamp
    local repo remote branch head
    head=$(in_repo git symbolic-ref HEAD) || \
        die "HEAD does not point at a branch, will not be able to clone barclamp."
    for branch in $(all_ordered_branches); do
        in_repo branch_exists "$branch" && \
            is_in "$1" "$(barclamps_in_branch $branch)" || continue
        remote="$(in_repo remote_for_branch "$branch")"
        quiet_checkout "$branch"
        in_repo git submodule init "barclamps/$1" || {
            in_repo git config --unset "submodule.barclamps/$1.url"
            quiet_checkout "${head#refs/heads/}"
            continue
        }
        repo="$(get_repo_cfg "submodule.barclamps/$1.url")"
        repo="${repo##*/}"
        repo="${repo##*:}"
        repo="$(remote_urlbase "$remote")/$repo"
        if [[ $repo =~ $github_re ]] && remote_available personal; then
            # test to see if we need to fork this barclamp at Github
            local r="${repo##*/}"
            r="${r%.git}"
            github_repo_exists "$r" "$remote" || \
                die "Cannot find $repo on github. clone_barclamp giving up."
            github_repo_exists "$r" || github_fork "$remote" "$r" || \
                die "Unable to fork $repo. clone_barclamp giving up."
        fi
        in_repo git config "submodule.barclamps/$1.url" "$repo"
        in_repo git submodule update "barclamps/$1" || {
            quiet_checkout "${head#refs/heads/}"
            continue
        }
        quiet_checkout "${head#refs/heads/}"
        sync_barclamp_remotes "$1"
        in_barclamp "$1" git remote rm origin
        in_barclamp "$1" update_tracking_branches
        in_barclamp "$1" quiet_checkout master
        return
    done
    die "Asked to clone $1, but could not!"
}

# Check out a branch, but be quiet about it unless something goes wrong.
quiet_checkout() {
    local res=''
    res=$(git checkout -q "$@" 2>&1) && return
    echo "$res" >&2
    return 1
}

# Set up barclamps for the appropriate branch.  Barclamps that are not members
# of the current branch will be checked out to an empty branch, which will be
# created if it does not exist.
switch_barclamps_to() {
    # $1 = Either a branch or "submodule-ref"
    local -A barclamps
    local m t ref to_ref p bc head
    # Read barclamps that should be there.
    while read m t ref p; do
        [[ $m = 160000 && $t = commit ]] || continue
        if [[ $1 = submodule-ref ]]; then
            # We want the exact git commit that this branch says we should be at.
            barclamps[${p##*/}]=$ref
        else
            # We don't care about the submodule reference, just check out the
            # proper branch in the submodule for this release.
            barclamps[${p##*/}]="refs/heads/$1"
        fi
    done < <(in_repo git ls-tree HEAD barclamps/)
    # Update barclamps that are there.
    for bc in "$CROWBAR_DIR/barclamps/"*; do
        # If there is a directory present but no barclamp, try to clone first.
        [[ -d $bc/.git || -f $bc/.git ]] || clone_barclamp "${bc##*/}"
        bc="${bc##*/}"
        case ${barclamps[$bc]} in
            # Switch to the appropriate branch if we are not already there.
            refs/heads/*) ref="$(in_barclamp "${bc}" git symbolic-ref HEAD)"
                if [[ $ref != ${barclamps[$bc]} ]]; then
                    to_ref="${ref%/*}/master"
                    to_ref="${to_ref#refs/heads/}"
                    in_barclamp "$bc" branch_exists "$to_ref" || \
                        die "No branch $to_ref in barclamp $bc! Switching releases failed."
                    in_barclamp "$bc" quiet_checkout "$to_ref"
                fi;;
            # Check out a specific commit in the barclamp
            ?*) ref=$(in_barclamp "${bc##*/}" git rev-parse --verify -q HEAD)
                to_ref=$(in_barclamp "${bc##*/}" git rev-parse --verify -q "${barclamps[$bc]}") || \
                    die "Target ref $to_ref does not exist in barclamp $bc. Try fetching and syncing."
                [[ $ref != $to_ref ]] && in_barclamp "${bc}" quiet_checkout "$to_ref";;
            # This barclamp is not listed, check out the empty branch instead.
            '') in_barclamp "${bc##*/}" to_empty_branch;;
            *) die "Cannot happen in switch_barclamps_to. Email crowbar@lists.us.dell.com.";;
        esac
        [[ ${barclamps[$bc]} ]] && unset barclamps[$bc]
    done
    # Create barclamps that are not there.
    for bc in "${!barclamps[@]}"; do
        [[ ${barclamps[$bc]} ]] || continue
        clone_barclamp "${bc##*/}"
        in_barclamp "${bc##*/}" quiet_checkout "${barclamps[$bc]}" || \
            die "Cannot check out ${barclamps[$bc]} in freshly-cloned barclamp $bc"
    done
}

clear_tracking_info() {
    local line k v branch_re='^branch\..*\.(merge|remote)$'
    while read line; do
        k=${line%%=*}
        v=${line#*=}
        [[ $k =~ $branch_re ]] || continue
        git config --unset "$k"
    done < <(git config --list)
}

# Update tracking branches for all remotes in a specific repo.
# Expects to be called within a specific repository
update_tracking_branches() {
    # Create tracking branches for any branches from this remote
    # that do not already exist.
    local remote
    clear_tracking_info
    while read remote; do
        git_remote_exists "$remote" || continue
        while read p br; do
            [[ $br = refs/remotes/$remote* ]] || continue
            br=${br#refs/remotes/$remote/}
            [[ $br = HEAD ]] && continue
            [[ $br = personal/* ]] && continue
            [[ $br = pull-req* ]] && continue
            branch_exists "$br" || git branch "$br" "$remote/$br" >&/dev/null
            git_config_has "branch.$br.remote" || \
                git config "branch.$br.remote" "$remote"
            git_config_has "branch.$br.merge" || \
                git config "branch.$br.merge" "refs/heads/$br"
        done < <(git show-ref)
    done < <(sorted_remotes)
}

update_all_tracking_branches() {
    local bc
    debug "Updating tracking branch references"
    in_repo update_tracking_branches
    for bc in "$CROWBAR_DIR/barclamps/"*; do
        [[ -d $bc/.git || -f $bc/.git ]] || continue
        (cd "$bc"; update_tracking_branches)
    done
}

scrub_merged_pull_requests() {
    dev_is_setup || return 0
    # $@ = branches to test for mergedness
    local br ref pull_req
    local -A to_remove pull_reqs heads
    remote_available personal || return
    while read ref br; do
        case $br in
            refs/heads/*)
                ref=${br#refs/heads/}
                heads[${ref//\//-}]+="$br ";;
            refs/remotes/personal/pull-req-*)
                ref=${br#refs/remotes/personal/pull-req-}
                ref=${ref#heads-}
                ref=${ref%-*}
                ref=${ref%-0}
                pull_reqs["$br"]="$ref";;
        esac
    done < <(git show-ref)
    [[ ${pull_reqs[*]} ]] || return 0
    for pull_req in "${!pull_reqs[@]}"; do
        ref="${pull_reqs[$pull_req]}"
        [[ ${heads[$ref]} ]] || continue
        for br in ${heads["$ref"]}; do
            branches_synced . "$br" "$pull_req" || \
                [[ $1 = '--all' ]] || continue
            to_remove["${pull_req#refs/remotes/personal/}"]="true"
            continue 2
        done
    done
    [[ ${!to_remove[*]} ]] || return
    git_push --delete personal "${!to_remove[@]}"
    git remote prune personal
}

# Fetch (but do not merge) updates from all our remotes, in both the
# main Crowbar repository and the barclamps.
fetch_all() {
    local remote remotes=() barclamp bc bc_remote branches=()
    local -A fetched_barclamps
    if [[ $@ || $DEV_FROM_REMOTES ]]; then
        [[ $1 ]] && remotes+=("$@")
        [[ $DEV_FROM_REMOTES ]] && remotes+=("${DEV_FROM_REMOTES[@]}")
    else
        remotes=($(sorted_remotes))
    fi
    for remote in "${remotes[@]}"; do
        crowbar_remote_exists "$remote" && remote_available "$remote" || continue
        debug "Fetching from remote $remote:"
        debug "    Crowbar"
        in_repo git fetch -q "$remote" || continue
        for bc in "$CROWBAR_DIR/barclamps/"*; do
            [[ -d $bc/.git || -f $bc/.git ]] || continue
            bc=${bc##*/}
            in_barclamp "${bc}" git_remote_exists "$remote" || continue
            debug "    Barclamp $bc"
            in_barclamp "$bc" git fetch -q "$remote" || \
                echo "Could not fetch updates for $barclamp from remote $remote" >&2
        done
        [[ $remote = personal ]] && scrub_merged_pulls || :
    done
    update_all_tracking_branches
}

scrub_merged_pulls() {
    in_repo scrub_merged_pull_requests "$@"
    for barclamp in "$CROWBAR_DIR/barclamps/"*; do
        [[ -d $barclamp ]] || continue
        in_barclamp "${barclamp##*/}" scrub_merged_pull_requests "$@"
    done
}

# Helper function for calling curl to talk to github.
curl_and_res() {
    local __r="$(curl -n "$@" 2>/dev/null)"
    case $? in
        0) printf '%s' "$__r";;
        7) echo "Unable to contact Github, please try again later." >&2
            return 1;;
        22) return 1;;
        *) echo "Curl reported error ${?}!." >&2
            return 1;;
    esac
}

github_repo_exists() {
    # $1 = repo to check for
    # $2 = user to check for it in.  Defaults to $DEV_GITHUB_ID
    local repo=$1 user=${2-$DEV_GITHUB_ID}
    curl_and_res -f -X GET "https://api.github.com/repos/$user/$repo" >&/dev/null
}

# Fork a repository on Github.
github_fork() {
    # $1 = user to fork from
    # $2 = repo to fork
    curl_and_res -f -X POST \
        "https://api.github.com/repos/$1/$2/forks" >&/dev/null || \
        die "Could not fork $1/$2! (your .netrc file may be missing)"
}

get_repo_name() {
    local repo
    repo="$(git_url_for_remote $(origin_remote))" || \
        repo="$(git_url_for_remote origin)" || \
        die "$PWD: Could not get the URL for the origin remote for this repo."
    repo="${repo##*:}"
    echo "${repo##*/}"
}

git_remote_exists() { git_config_has "remote.$1.url"; }
crowbar_remote_exists() { in_repo git_config_has "crowbar.remote.$1.urlbase"; }

git_url_for_remote() { git_remote_exists "$1" && git config --get "remote.$1.url"; }

add_remote() {
    # $1 = name of the remote to add.
    # $2 = base part of the repo to add.
    git_remote_exists "$1" && return 0
    local repo
    repo="$(get_repo_name)" || exit 1
    repo="$2/$repo"
    git ls-remote "$repo" refs/heads/master &>/dev/null || {
        debug "No git repo at $repo, skipping."
        return 0
    }
    git remote add "$1" "$repo"
    git fetch "$1"
    update_tracking_branches
}

rm_remote() {
    git_remote_exists "$1" && git remote rm "$1"
    update_tracking_branches
}

set_url_remote() {
    git_remote_exists "$1" || return 0
    local repo
    repo="$(get_repo_name)" || exit 1
    repo="$2/$repo"
    git ls-remote "$repo" refs/heads/master &>/dev/null || {
        debug "No git repo at $repo, skipping."
        return 0
    }
    git remote set-url "$1" "$repo"
    git fetch "$1"
    update_tracking_branches
}

sync_barclamp_remotes() {
    # $1 = barclamp to synchronize Crowbar remotes into.
    # We will ignore the origin remote.
    local remote urlbase remote_repo barclamp_repo
    while read remote urlbase; do
        barclamp_repo="$(get_repo_cfg "submodule.barclamps/$bc.url")"
        barclamp_repo="${barclamp_repo##*/}"
        barclamp_repo="${barclamp_repo##*:}"
        barclamp_repo="${barclamp_repo}"
        remote_repo=$(in_barclamp "$1" git_url_for_remote "$remote")
        [[ ${remote_repo%.git} = $urlbase/${barclamp_repo%.git} ]] && continue
        local update_tracking=true
        debug "Synchronizing remotes for barclamp $bc"
        if in_barclamp "$1" git_remote_exists "$remote"; then
            in_barclamp "$1" set_url_remote "$remote" "$urlbase" || \
                die "Could not update remote $remote for barclamp $1 in sync_barclamp_remotes"
        else
            in_barclamp "$1" add_remote "$remote" "$urlbase" || \
                die "Could not add new remote $remote for barclamp $1 in sync_barclamp_remotes"
        fi
    done < <(show_remote)
    if [[ $update_tracking ]]; then
        in_barclamp "$1" update_tracking_branches
    fi
}

show_remote() {
    local line remote url remote_re='^crowbar\.remote\.([^.]+)\.urlbase=(.*)$'
    while read line; do
        [[ $line =~ $remote_re ]] || continue
        remote=${BASH_REMATCH[1]}
        url=${BASH_REMATCH[2]}
        if [[ $1 && $1 = $remote ]]; then
            echo  "$remote urlbase=$url priority=$(remote_priority $remote)"
        elif [[ ! $1 ]]; then
            echo "$remote $url"
        fi
    done < <(in_repo git config --list |grep '^crowbar\.remote\.')
}

sorted_remotes() {
    local __remotes=() remote u
    while read remote u; do
        __remotes[$(remote_priority $remote)]+="$remote "
    done < <(show_remote)
    printf "%s\n" ${__remotes[@]}
}

remote_is_github() {
    git_remote_exists "$1" && crowbar_remote_exists "$1" || \
        return 1
    [[ $(get_repo_cfg "crowbar.remote.$1.urlbase") =~ $github_re ]]
}

remote_github_account() {
    remote_is_github "$1" || return 1
    echo "${BASH_REMATCH[1]}"
}

remote_priority() {
    # $1 = remote name
    crowbar_remote_exists "$1" || return 1
    in_repo git_config_has "crowbar.remote.$1.priority" || echo 50
    get_repo_cfg "crowbar.remote.$1.priority"
}

remote_wrapper() {
    # $1 = one of "add", "rm", "set-url", "show"
    # $2 = name of remote
    # $3 = base part of the remote URL.  Only used for add and set-url.
    local remote urlbase action bc cfgaction=()
    remote="$2"
    urlbase="$3"
    case $1 in
        add)
            action=add_remote
            if [[ ! $urlbase && $remote =~ $github_re ]]; then
                urlbase="$2"
                remote="${BASH_REMATCH[1]}"
            fi
            if crowbar_remote_exists "${remote}"; then
                die "We already have a remote for $remote."
            fi
            cfgaction=(in_repo git config "crowbar.remote.${remote}.urlbase" "$urlbase")
            ;;
        rm)
            action=rm_remote
            if ! crowbar_remote_exists "${remote}"; then
                die "No remote named $remote to remove."
            fi
            local r=($(sorted_remotes))
            (( ${#sorted_remotes[@]} == 1)) && \
                die "$1 is your last remote.  Can't remove it."
            cfgaction=(in_repo git config --unset "crowbar.remote.${remote}.urlbase")
            ;;
        set-url)
            action=set_url_remote
            if ! crowbar_remote_exists "${remote}"; then
                die "Cannot set-url for a remote your have not added."
            fi
            cfgaction=(in_repo git config "crowbar.remote.${remote}.urlbase" "$urlbase")
            ;;
        show) shift;
            show_remote "$1"
            return;;
        sync) action=sync_barclamp_remotes;;
        priority)
            crowbar_remote_exists "$2" || \
                die "Remote $2 must be configured before you can set its priority."
            [[ $3 =~ [0-9]+ ]] && (($3 > 0 && $3 <= 100)) || \
                die "Priority must be a number between 1 and 100"
            in_repo git config "crowbar.remote.$remote.priority" "$3"
            update_all_tracking_branches
            return;;
        ''|help) die "Please pass one of add, rm, set-url, sync, priority, or show.";;
        *) die "Unknown action $1 for remote.";;
    esac
    for bc in "$CROWBAR_DIR/barclamps/"*; do
        [[ -d $bc/.git || -f $bc/.git ]] || continue
        debug "Barclamp: ${bc##*/}"
        in_barclamp "${bc##*/}" $action "$remote" "$urlbase"
    done
    debug "Crowbar:"
    "${cfgaction[@]}"
    if [[ $action != sync_barclamp_remotes ]]; then
        in_repo $action "$remote" "$urlbase"
    fi
}

migrate_1_to_2() {
    local url=$(get_repo_cfg "remote.origin.url")
    if [[ $url =~ $github_re ]]; then
        local account="${BASH_REMATCH[1]}"
        local urlpart="https://github.com/${BASH_REMATCH[1]}"
    else
        die "Initial fork of Crowbar must come from Github!"
    fi
    remote_wrapper add "$account" "$urlpart"
    remote_wrapper priority "$account" 5
    update_all_tracking_branches
    for rb_source in "${!DEV_REMOTE_BRANCHES[@]}"; do
        rb="${DEV_REMOTE_BRANCHES[$rb_source]}"
        [[ $rb_source = origin ]] && rb_source="$account"
        if [[ ${DEV_REMOTE_SOURCES[$rb_source]} ]]; then
            crowbar_remote_exists "$rb_source" && continue
            remote_available "$rb_source" || continue
            remote_wrapper add "$rb_source" "${DEV_REMOTE_SOURCES[$rb_source]}"
        fi
    done
    set_branch_graph $(for b in "${!DEV_BRANCHES[@]}"; do
        echo "${DEV_BRANCHES[$b]}:$b"
        done)
    crowbar_remote_exists origin && remote_wrapper rm origin
    in_repo git_remote_exists origin && in_repo git remote rm origin
    for bc in "${CROWBAR_DIR}/barclamps/"*; do
        [[ -d $bc/.git || -f $bc/.git ]] || continue
        in_barclamp "${bc##*/}" git_remote_exists origin && \
            in_barclamp "${bc##*/}" git remote rm origin
    done
    for bc in $(in_repo git config --list |grep '^crowbar.backup'); do
        in_repo git config --unset "${bc%%=*}"
    done
    unset b rb rb_source DEV_REMOTE_BRANCHES DEV_REMOTE_SOURCES DEV_BRANCHES
}

migrate() {
    # $1 = source revision
    # $2 = target revision
    local src_rev=${1:-0} target_rev=${2:-$DEV_VERSION} i
    if ((src_rev == 0)) && in_repo git_config_has crowbar.dev.version; then
        src_rev=$(get_repo_cfg crowbar.dev.version)
    fi
    ((src_rev == target_rev)) && return
    [[ $DEV_AVAILABLE_REMOTES ]] && {
        echo "dev setup must have access to all your configured remotes to continue."
        echo "DEV_AVAILABLE_REMOTES is set, indicating that some of your remotes are not available."
        echo "dev setup is aborting."
        exit 1
    } >&2
    ((src_rev > target_rev)) && \
        die "Cannot migrate down from $src_rev to $target_rev."
    for ((i=src_rev; i < target_rev; i++)); do
        grep -q 'function' < <(LC_ALL=C type "migrate_${i}_to_$(($i + 1))" 2>/dev/null) || continue
        "migrate_${i}_to_$(($i + 1))" || \
            die "Migration from $src_rev to $target_rev failed at rev $i"
    done
}


# Perform initial setup.  If you make any changes to this function, take
# care to make sure it stays idempotent.
setup() {
    local p remote release br head
    local -A touched_branches barclamps
    [[ $head ]] || head=$(in_repo git symbolic-ref HEAD) || \
        die "HEAD does not point at a branch, cannot finish setup."
    crowbar_is_clean || \
        die "Crowbar repo must be clean before trying to set things up!"
    # Make sure we have Github login credentials as the very first thing.
    [[ $DEV_GITHUB_ID ]] || {
        local DEV_GITHUB_PASSWD
        read -p "Enter your Github username: " DEV_GITHUB_ID
        curl_and_res -f \
            "https://api.github.com/users/$DEV_GITHUB_ID" &>/dev/null || \
            die "Could not verify that $DEV_GITHUB_ID is a valid Github user.."
        while [[ $p != $DEV_GITHUB_PASSWD || ! $p ]]; do
            [[ $p ]] && echo "Passwords did not match, try again."
            read -s -p "Enter your Github password: " DEV_GITHUB_PASSWD
            echo
            read -s -p "Enter your Github password again: " p
            echo
        done
        curl_and_res -f -u "$DEV_GITHUB_ID:$DEV_GITHUB_PASSWD" \
            https://api.github.com/user &>/dev/null || {
            echo "Unable to authenticate as Github user $DEV_GITHUB_ID." >&2
            die "Please try again when you have Github access."
        }
        for mach in github.com api.github.com; do
            grep -q "^$mach" "$HOME/.netrc" &>/dev/null && continue
            printf "\nmachine %s login %s password %s\n" \
                "$mach" "$DEV_GITHUB_ID" "$DEV_GITHUB_PASSWD" >> "$HOME/.netrc"
        done
        chmod 600 "$HOME/.netrc"
        printf "DEV_GITHUB_ID=%q\n" "$DEV_GITHUB_ID" >> "$HOME/.build-crowbar.conf"
    }
    # We have a baked-in assumption that Github is our origin, and that
    # any repositories that are named the same thing as a repository from
    # $(origin_remote) is in fact a fork of a $(origin_remote) repo.
    # We should not make that assumption at some point in the future.
    migrate "$(get_repo_cfg crowbar.dev.version)" "$DEV_VERSION"
    if ! github_repo_exists crowbar; then
        echo "Creating your fork of Crowbar on Github."
        github_fork "$(origin_remote)" crowbar || \
            die "Unable to create your fork of Crowbar."
    fi
    if ! crowbar_remote_exists "$(origin_remote)"; then
        echo "Configuring $(origin_remote) remote for Crowbar"
        remote_wrapper add "$(origin_remote)" "https://github.com/$(origin_remote)"
        in_repo git config "crowbar.remote.$(origin_remote).priority" 5
    fi
    if [[ $(origin_remote) != $DEV_GITHUB_ID ]] && \
        ! crowbar_remote_exists personal; then
        echo "Adding remote for personal fork of crowbar on Github."
        remote_wrapper add personal "https://github.com/$DEV_GITHUB_ID"
        remote_wrapper priority personal 95
    fi
    in_repo git config branch.autosetupmerge true &>/dev/null
    in_repo git config crowbar.backup.method per-remote
    head_release="$(current_release)"
    # Set up the rest of our upstream remotes.
    if crowbar_remote_exists personal && \
        ! in_repo git_config_has "crowbar.backup.$(origin_remote).method"; then
        in_repo git config crowbar.backup.$(origin_remote).method remote
        in_repo git config crowbar.backup.$(origin_remote).remote personal
    fi
    local -A barclamps
    for b in $(all_ordered_branches); do
        in_repo branch_exists "$b" && \
            remote_available "$(in_repo remote_for_branch "$b")" || continue
        in_repo quiet_checkout "$b"
        for bc in $(barclamps_in_branch "$b"); do
            [[ ${barclamps[$bc]} ]] && continue
            if ! in_repo git_config_has "submodule.barclamps/$bc.url"; then
                debug "Performing initial clone of barclamp $bc"
                clone_barclamp "$bc"
            else
                sync_barclamp_remotes "$bc"
            fi
            in_barclamp "$bc" git config branch.autosetupmerge true
            barclamps[$bc]="touched"
        done
    done
    [[ $head ]] && in_repo quiet_checkout "${head#refs/heads/}"
    switch_release "$(current_release)"
    in_repo git config crowbar.dev.version "$DEV_VERSION"
}

# Test repository $1 to see if commit $2 is in sync with $3.
# In this case, "in sync" is defined as:
#  * $2 and $3 point at the same commit, or
#  * There are no commits in the set of all commits reachable from $3 that
#    are not also reachable from $2.
branches_synced() {
    # $1 = repository to operate in
    # $2 = local branch to test
    # $3 = remote branch to test
    [[ -d $1/.git || -f $1/.git ]] || \
        die "branches_synced: $1 is not a git repo"
    [[ $VERBOSE2 ]] && echo "Checking to see if out of sync: $2 $3"
    (cd "$1"; git rev-parse --verify -q "$2" &>/dev/null) || \
        return 1
    (cd "$1"; git rev-parse --verify -q "$3" &>/dev/null) || \
        return 1
    # $2 and $3 resolve to the same commit, they are in sync.
    (cd "$1"; [[ $(git rev-parse "$2") = $(git rev-parse "$3") ]] ) && return 0
    # Test to see if there are any commits in $3 that are not
    # reachable from $2.  If there are, then the branches are not synced.
    (cd "$1"; [[ ! $(git rev-list "$2..$3") ]] ) && return 0
    return 1
}

get_backup_var() {
    local res=''
    res=$(get_repo_cfg "crowbar.backup.$remote.$1") || \
        return 1
    echo "$res"
}

# Back up any local commits that are not already present on our upstreams,
# or that have not already been backed up.
backup_repo() {
    local id bc branch remote branch_get_func branch_backup_func
    local -A branches backup_remotes
    local backup_method target_remote target_method target_prefix
    local remote_re='^refs/remotes/([^/]+)'
    while read id branch; do
        if [[ $branch = refs/heads/* ]]; then
            # This is a local ref, see if it needs backed up.
            branch=${branch#refs/heads/}
            # Does this branch have a remote, and is it one that Crowbar cares about?
            remote=$(remote_for_branch "$branch") || continue
            crowbar_remote_exists "$remote" && remote_available "$remote" || continue
            # If we already know what the backup remote is for this branch is based
            # on the upstream remote for the branch is, carry on.
            [[ ${backup_remotes[$remote]} ]] || {
                # Otherwise, firgure out whether this branch is from a remote we are backing up.
                backup_remote=$(get_backup_var remote) && \
                    crowbar_remote_exists "$backup_remote" && \
                    git_remote_exists "$backup_remote" && \
                    remote_available "$backup_remote" || \
                    continue
                backup_remotes[$remote]="${backup_remote}"
            }
            if ! git rev-parse --verify -q \
                "refs/remotes/${backup_remotes[$remote]}/$branch" &> /dev/null || \
                [[ $(git rev-parse "refs/remotes/${backup_remotes[$remote]}/$branch") != \
                $(git rev-parse "refs/heads/${branch}") ]]; then
                # Only back up branches that either don't exist on the backup remote
                # for this branch, or that do exist but don't point at the commit we want.
                branches[${backup_remotes[$remote]}]+="$branch "
            fi
        elif [[ $branch =~ $remote_re ]]; then
            # This is a remote ref, see if we care about it and need to delete it.
            remote="${BASH_REMATCH[1]}"
            # Is this a remote we are using as a backup target?
            is_in "$remote" "${backup_remotes[*]}" || continue
            branch=${branch#refs/remotes/${remote}/}
            # Skip any pull request branches.
            [[ $branch = pull-req-* || $branch = HEAD ]] && continue
            # Skip any branches that have a local head.
            git show-ref --verify --quiet "refs/heads/$branch" && continue
            # Schedule the branch for deletion.
            branches["$remote"]+=":${branch} "
        fi
    done < <(LC_ALL=C git show-ref |sort -k2) # Sort ensures that local refs always come first.
    # Now, we know what to back up, what to ignore, and what to delete.
    # Make it so.
    for remote in "${!branches[@]}"; do
        [[ ${branches[$remote]} ]] || continue
        git_push -f "$remote" ${branches[$remote]}
    done
}

backup_everything() {
    local bc remote branches=() branch remotes=()
    local -A touched_bcs
    dev_is_setup || die "You must run dev setup before trying to back things up to Github."
    # Back up all the barclamps that are references as submodules for
    # branches that this remote is "authoritative" for.
    for bc in "$CROWBAR_DIR/barclamps/"*; do
        [[ -d $bc/.git || -f $bc/.git ]] || continue
        debug "Backing up barclamp ${bc##*/}"
        in_barclamp "${bc##*/}" backup_repo
    done
    debug "Backing up Crowbar"
    in_repo backup_repo
}

merge_or_rebase_from_remote() {
    # $1 = remote
    # $2 = local branch
    local remote branch rebase_temp
    remote="$1" branch="$2" rebase_temp="$branch-rebase"
    git rev-parse --verify -q "$remote/$branch" &>/dev/null || return 0
    branches_synced "." "refs/heads/$branch" "refs/remotes/$remote/$branch" && return 0
    [[ $head ]] || head=$(git symbolic-ref HEAD) || \
        head=$(git rev-parse HEAD) || die "$repo: Cannot find head commit."
    quiet_checkout "$branch" || die "$remote: Unable to checkout $branch!"
    git branch -f --no-track "$rebase_temp" "$branch"
    debug "$repo: Merging $remote/$branch into $branch"
    git merge -q "$remote/$branch" || {
        git merge --abort
        die "$repo: Unable to merge $remote/$branch into $branch, aborted"
    }
    if [[ $allow_remote_rebase = true ]] && \
        crowbar_remote_exists "$remote" && \
        [[ ! $DEV_FROM_REMOTES ]]; then
        if ! git rebase -p -q "$remote/$branch" "$rebase_temp" &>/dev/null; then
            git rebase --abort
            quiet_checkout "$branch"
        elif ! git diff --exit-code "$branch" "$rebase_temp"; then
            quiet_checkout "$branch"
        else
            debug "$repo: Rebased version of $branch is identical to merged version."
            debug "$repo: Using the rebased version instead."
            quiet_checkout "$branch"
            git reset --hard "$rebase_temp"
        fi
    fi
    git branch -D "$rebase_temp" &>/dev/null
}

# Handle merges across releases.  Most of the ugliness here is around making
# sure that we don't get merge conflicts due to different barclamp submodule
# updates, which we don't care about locally.
merge_releases() {
    # $@ = releases to merge.
    local rel ref branch br mode t bc
    local cur_rel="$(current_release)"
    local -A our_barclamps their_barclamps
    for branch in $(branches_for_release); do
        br="${branch##*/}"
        quiet_checkout "$branch" || \
            die "Could not checkout $branch in merge_releases!"
        # Save our current barclamp references to be restored later.
        if [[ -d barclamps ]]; then
            while read mode t ref bc; do
                [[ $mode = '160000' && $t = 'commit' ]] || continue
                our_barclamps["$bc"]="$ref"
            done < <( git ls-tree -r HEAD barclamps)
        fi
        for rel in "$@"; do
            [[ $rel ]] || continue
            [[ $rel != $cur_rel ]] || continue
            release_exists "$rel" || continue
            local from_prefix="$(branch_prefix "$rel")"
            branch_exists "${from_prefix}$br" || continue
            if [[ -d barclamps ]]; then
                local do_commit=''
                # Find all the common barclamps that point at different
                # submodule references.  Make the current branch point at the
                # same refs as the to-be-merged branch to avoid merge conflicts
                # that we really don't care about locally anyways.
                while read mode t ref bc; do
                    [[ ${our_barclamps[$bc]} && \
                        ${our_barclamps[$bc]} != $ref ]] || continue
                    git update-index --cacheinfo 160000 "$ref" "$bc"
                    do_commit=true
                done < <(git ls-tree -r "${from_prefix}$br" barclamps)
                [[ $do_commit ]] && \
                    git commit -m "Eschew barclamp merge conflicts."
                unset do_commit
            fi
            git merge -q "${from_prefix}$br" || {
                echo "Could not automatically merge.  Dropping to a shell."
                echo "If you want to abort this merge, exit the shell with 'exit 1'"
                /bin/bash
            } || {
                git merge --abort
                die "$repo: Merge of $br from $rel into $cur_rel failed."
            }
        done
        if [[ -d barclamps ]]; then
            # Unwind submodule updates for barclamps.  This leaves them
            # out of sync from where they really should be at this point,
            # but the policy of the dev tool is that all "real" barclamp
            # submodule reference updates happen at pull-requests-gen time.
            while read mode t ref bc; do
                [[ ${our_barclamps[$bc]} && \
                    ${our_barclamps[$bc]} != $ref ]] || continue
                ref="${our_barclamps[$bc]}"
                git update-index --cacheinfo 160000 "$ref" "$bc"
                do_commit=true
            done < <(git ls-tree -r HEAD barclamps)
            [[ $do_commit ]] && {
                git commit -m "Move barclamp submodule refs back."
                debug "Submodules updated for $branch in Crowbar."
                debug "Builds with --exact will be broken until this branch has been through a pull request."
            }
            unset do_commit
        fi
    done
}

# Merges in changes into all local branches from their upstreams.
# Assumes that upstream commits have already been fetched from the proper
# remotes by running dev fetch.
sync_repo() (
    local branch head b rel bc remote ref repo="$1"
    shift
    # $repo = dir to CD to initially.
    # Assumes that remote has already been fetched.
    cd "$repo"
    # Repo is not clean, we will refuse to merge in any case.
    git_is_clean || exit 1
    # Merge upstream branches from
    [[ $head ]] || head=$(git symbolic-ref HEAD) || \
        head=$(git rev-parse HEAD) || die "$repo: Cannot find head commit."
    while read ref branch; do
        branch=${branch#refs/heads/}
        remote="$(remote_for_branch "$branch")" || continue
        merge_or_rebase_from_remote "$remote" "$branch"
    done < <(git show-ref --heads)
    if [[ $(git rev-parse --verify -q HEAD) != \
        $(git rev-parse --verify -q $head) ]]; then
        quiet_checkout "${head#refs/heads/}"
    fi
    if [[ $@ ]]; then
        merge_releases "$@"
        quiet_checkout "${head#refs/heads/}"
    fi
    return 0
)

# Recursivly merge all changes from a given branch into its children, if any.
# Parent -> child relations are defined by the structure of DEV_BRANCHES.
ripple_changes_out() {
    # $1 branch to ripple changes from. Changes will be rippled to all
    # children of $1.
    local parent="$1" child
    in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
        die "ripple_changes_out: $parent is not a branch in Crowbar!"
    for child in $(child_branches "$parent"); do
        in_repo git rev-parse --verify -q "$parent" &>/dev/null || \
            die "ripple_changes_out: $child is not a branch in Crowbar!"
        if ! branches_synced "$CROWBAR_DIR" \
            "refs/heads/$child" "refs/heads/$parent"; then
            [[ $(in_repo git symbolic-ref HEAD) = refs/heads/$child ]] || \
                in_repo quiet_checkout "$child"
            debug "Merging $parent into $child"
            in_repo git merge -s recursive -X theirs -q "$parent" || \
                die "Merge $parent into $child branch of Crowbar failed."
        fi
        ripple_changes_out "$child"
    done
}

demangle_barclamp_refs() {
    local br remote bc from_ref to_ref base_ref bc_re='^160000 commit ([0-9a-f]+)'
    local head need_commit
    while read br; do
        remote=$(remote_for_branch "$br") || continue
        in_repo branches_synced . "$remote/$br" "$br" && continue
        debug "Branch $br: Checking for mangled submodule references"
        while read bc; do
            from_ref=$(in_repo git ls-tree "$remote/$br" "barclamps/$bc")
            to_ref=$(in_repo git ls-tree "$br" "barclamps/$bc")
            # If the barclamp is not present locally or remotely, we will not get
            # merge conflicts, so we can continue.
            [[ $from_ref =~ $bc_re ]] || continue
            from_ref="${BASH_REMATCH[1]}"
            [[ $to_ref =~ $bc_re ]] || continue
            to_ref="${BASH_REMATCH[1]}"
            # If the barclamp is at the same revision locally and remotely, we are OK.
            [[ $from_ref = $to_ref ]] && continue
            # The barclamp is not at the same revision remotely or locally.
            # Check to see what we should do based on its state in the merge base for the
            # remote and local branches.
            base_ref=$(in_repo git ls-tree \
                "$(in_repo git merge-base "$br" "$remote/$br" |head -1)" \
                "barclamps/$bc")
            if ! [[ $base_ref =~ $bc_re ]]; then
                # Oh my, the barclamp is not present in the merge base.
                # Strange things are afoot at the Circle K.
                # Complain and die for now.
                die "Barclamp $bc added seperately locally and in remote $remote.
This needs manual intervention."
            fi
            base_ref="${BASH_REMATCH[1]}"
            if [[ $base_ref = $to_ref ]]; then
                # The remote was updated remotely and not locally.
                # This will merge correctly, so we don't have to worry.
                continue
            fi
            # Either a submodule reference was updated locally but not remotely,
            # or a submodule reference was updated both locally and remotely.
            # The proper action in either case is to revert the local reference
            # to the base reference, which give us a nonconflicting merge.
            echo "Undoing git add barclamps/$bc in branch $br" >&2
            [[ $head ]] || head=$(in_repo git symbolic-ref HEAD) || \
                head=$(in_repo git rev-parse HEAD) || die "$repo: Cannot find head commit."
            [[ $need_commit ]] || in_repo git checkout "$br"
            in_repo git update-index --cacheinfo 160000 "$base_ref" "barclamps/$bc"
            need_commit=true
        done < <(barclamps_in_branch "$br")
        [[ $need_commit ]] || continue
        need_commit=''
        in_repo git commit -m "Rolling back local barclamp submodule reference updates"
    done < <(all_ordered_branches)
}

# Merge all changes from our upstreams for all barclamps and the main Crowbar
# repository, and then update the branches for the current release according
# to the branch structure defined in DEV_BRANCHES.
sync_everything() {
    local unsynced_barclamps=()
    local b u head res=0 ref branch rel allow_remote_rebase=true
    crowbar_is_clean || exit 1
    # Do barclamps first.
    for b in "$CROWBAR_DIR/barclamps/"*; do
        debug "Syncing ${b##*/}"
        if ! sync_repo "$CROWBAR_DIR/barclamps/${b##*/}" "$@"; then
            unsynced_barclamps+=("${b##*/}")
            continue
        fi
    done
    # Finished with barclamps, now for crowbar.
    allow_remote_rebase=false
    debug "Syncing crowbar"
    demangle_barclamp_refs
    [[ $head ]] || head=$(git symbolic-ref HEAD) || \
        head=$(git rev-parse HEAD) || die "$repo: Cannot find head commit."
    sync_repo "$CROWBAR_DIR" "$@" || \
        die "Could not sync Crowbar with origin branches"

    # Now for the branch-rippling merges of doom
    for branch in $(root_branches); do
        ripple_changes_out "$branch"
    done
    if [[ $(git rev-parse --verify -q HEAD) != \
        $(git rev-parse --verify -q $head) ]]; then
        quiet_checkout "${head#refs/heads/}"
    fi
    if [[ $unsynced_barclamps ]]; then
        echo "Unable to sync origin with current master in:" >&2
        echo "  ${unsynced_barclamps[*]}"
        res=1
    fi
    [[ $res = 0 ]] && return 0
    echo
    echo "Please fix things up and rerun sync."
    return 1
}

dev_short_help() {
    cat <<EOF
$0: Development helper for Crowbar

setup:              Sets up a Crowbar checkout for use with dev.
is_clean:           Test to see if all work is committed.
fetch:              Fetch updates from configured upstream repositories.
remote:             Manage remotes across all Crowbar repositories.
backup:             Back up changes without merging them into upstream.
sync:               Synchronize fetched updates with the local repos.
push:               Unconditionally push a branch to your personal repos.
pull-requests-prep: Prepare to issue pull requests.
pull-requests-gen:  Issue pull requests.
release:            Show the current release or feature you are on.
releases:           Show all releases and features in your local repos.
branches:           Show the branches in the current release.
branch-graph:       Show or set the branch connectivity graph.
switch:             Switch to a different release.
checkout:           Check out a branch in the current release.
build:              build Crowbar.
cut_release:        Cut a new release from the current one.
new-feature:        Create a new feature bundle from the current release.
erase-feature:      Forget about branches for a feature you are not working on.
find-parent:        Find the closest parent of a release or feature.
reset-release:      Resets a release to upstream or your last backup.
scrub-merged-pulls: Scrub merged pull request branches.
setup-unit-tests:   Sets up unit test environment
reload-unit-tests:  Reload the data for the unit test environment
run-unit-tests:     Run unit and BDD tests
clear-unit-tests:   Remove unit test environment

For more detailed help, use the "help" command or read README.dev-and-workflow.
EOF
}

dev_help () {
    less <<EOF
$0: Development helper for Crowbar.

Command line options:

  setup -- Sets up your local Crowbar repositories for working with the
           new Github regime.  This command will prompt for your Github
           login information, make sure you have local copies of all the
           barclamp repos that Crowbar references checked out, create personal
           forks of all the crowbar repos from the $(origin_remote) account on
           github, and create the appropriate remotes needed for day-to-day
           operation.

  is_clean -- Check to see if the barclamps have everything committed
              with no untracked files, and check to see if the main
              Crowbar repository is clean while ignoring submodule references.

  fetch -- Fetch all changes from all of the configured Crowbar repositories.
           Does not try to merge any changes into your local repository.
           You can run a fetch at any time without disturbing your working
           code, provided you have network connectivity.
           If you pass the name of a remote, fetch will try to fetch changes
           from that remote in the main Crowbar repository and in each of the
           barclamps

  remote -- Manage remotes across all $(origin_remote) repositories.  It has the
            following subcommands:
            add <remote> <urlbase> : The add subcommand adds a new remote to
                the Crowbar repositories.
            rm <remote> : The rm subcommand removes an already-existing remote
                from the Crowbar repositories.
            set-url <remote> <urlbase> : The set-url subcommands allows you to
                give an existing remote a new URL in all the subrepositories.
            show <remote> : The show subcommand shows remote information for
                the named remote in all the Crowbar repositories.
            sync : Synchronize configured remotes from the main Crowbar repository
                to any cloned barclamps.
            priority <remote> <number>: Set the priority of a remote.
                This controls how local branches bind to remote branches -- any
                local branches that have a corresponding branch in a remote will
                be configured to track the remote with the smallest priority.
                By convention, the repository you cloned from will have a
                priority of 5, the personal repositiry on Github will have a
                priority of 95, and everything else will have a priority of 50.
                You can change the priority of a remote at any time, and your
                local tracking branches will be updated to reflect the new
                remote priority list.

           Note that <urlbase> is the URL got will use without the actual
           repository name.  dev assumes that the new remote uses the same
           repository name as the origin remote does, and things will fail
           badly if this assumption is violated.
           As an example, the urlbase for
              https://github.com/dellcloudedge/crowbar.git is
              https://github.com/dellcloudedge

  backup -- Push any locally committed changes in any repositories that were
            initially forked from $(origin_remote) into your personal Github forks.
            You can run a backup at any time without disturbing your working
            code, provided you have network connectivity.

  sync -- Merge any changes that have been fetched into the current
          repositories.  dev is_clean should exit without any messages before
          running this command.  If you pass an argument to sync, it will
          interpret that argument as a release or feature name and try to
          merge any changes in common branches from that release.

  push -- Unconditionally push a branch (or branches) to your crowbar Github
          fork.  Any arguments are interpreted as branch names to push, and
          if there are no arguments it pushes the branch you are currently on.
          Any branches pushed using this command will automatically be backed
          up when dev backup is run as well.

  pull-requests-prep -- Fetches, Syncs, and backs up all changes, then figures
                        out the set of barclamps and crowbar branches that
                        need to have pull requests created.  The output is a
                        command line that canbe copied and executed.

  pull-requests-gen -- Creates a set of pull requests with similar ids and
                       links based upon the barclamps dependency trees.  These
                       will be automatically sent to Github for processing and
                       review by the Dell review team.

  release -- Shows the current release that dev is operating on.

  releases -- Lists the releases to choose from.

  branches -- Shows the branches that are part of the specified release,
              or the current release if no release is specified.

  branch-graph -- Shows or sets the branch connectivity graph that dev uses
                  to handle how and when submodules are included in a build and
                  how the sync operation merges changes across branches in the
                  main Crowbar repository.
     show <branch> -- Show the connectivity graph starting from <branch>,
                      defaulting to master.
     add <parent1:child1> <parent2:child2> ...
         Set the branch connectivity graph.  You may pass any number of
         parent:child pairs, provided that the graph is fully connected and
         rooted in at least one master:master pair.  If --from is set, all
         branches passed to branch-graph set must be from the specified remotes,
         otherwise the passed branches will be associated with remotes according
         to the remote priority list.
     destroy <branch> -- Remove the subtree starting at <branch> from the
         connectivity graph.

  switch -- Change current release to the specified release, or the current
            release if no release name was passed.  This has the side effect
            of making sure that all the barclamps are on the proper branch for
            that release. dev switch will also set any barclamps that are not
            used in the new branch to an empty branch.

  checkout -- Change branch but stays in the release context if possible.
              Checkout will ensure that any barclamps that are ont being used
              by the new branch are set to an empty branch.

  build -- Set up the local trees and build a crowbar ISO.  Parameters:
           --os = operating system to stage Crowbar on to.
           --release = Release of Crowbar to build.
           --branch = Branch withina release of Crowbar to build
           --exact = If present, dev will run git submodule update after
                     processing the --release and --branch options, and the
                     --no-cache-update and --no-metadata-update parameters will
                     be passed to build_crowbar.sh.
                     If not present, the submodules will be checked out to the
                     appropriate master branch for the release.
           Any other parameters will be passed unchanged to build_crowbar.sh.
           See README.build for more information on building Crowbar.

  cut_release -- DO NOT USE UNLESS YOU KNOW WHAT YOU ARE DOING! Makes a new set
                 of branches and barclamp branches from the current release into
                 the new named release.  Must provide a unique new name.

  new-feature -- Create a new set of feature branches.  Must provide a unique
                 new name, and you must be in the development release when you
                 run this command.  Internally, features are implemented as
                 releases in the feature/ namespace, so all the other release
                 manipulation commands will work with them.

  erase-feature -- Erase feature branches created with new-feature.
                   This command is intended to be run after a feature has been
                   merged into the main devleopment stream to avoid cluttering
                   up the output of the git branch command.  It will fail if
                   the feature has not been merged into the development release.

  find-parent -- Find the parent of a release or feature based on the which
                 of the releases have the shortest merge distance from the
                 release passed to find-parent, so it is possible for more than
                 one release to be considered to be the parent. If that turns
                 out to be the case, find-parent wil ask you to disambiguate.

  reset-release -- Reset a release or feature to either the last pull from
                   upstream or your last backup.  Paremeters:
                   --release: Release to reset.  Defaults to current.
                   --target: Either "upstream" or "backup".
                             Defaults to "backup".
                   --skip-master: If set, will skip resetting the master branch
                                  in the release and any barclamps that the
                                  master branch pulls in.  Is automatically set
                                  if --release is not specified.
                   --skip-barclamps: Skip resetting the the barclamps for the
                                     release.

  scrub-merged-pulls -- Delete any tracking branches created as placeholders
                        for pull requests.  Without any options, this just
                        scrubs tracking branches for pull requests that have
                        already been merged.  If --all is passed as an option,
                        then all pull request tracking branches will be deleted.

  setup-unit-tests -- Sets up a unit test environment with all barclamps in /tmp/crowbar.
                      Requires sudo access to install Ubuntu packages.

  reload-unit-tests -- Reload the code and database for the units.  Does not re-bundle.

  run-unit-tests -- Run BDD and unit tests from the /tmp/crowbar environment.

  clear-unit-tests -- Removes a unit test environment in /tmp/crowbar.
EOF
}

# Tests to see if the given branch in a repo needs a pull request.
branch_needs_pull_req() {
    # $1 = branch
    local upstream=''
    if [[ $1 = feature/* ]]; then
        upstream="$to_remote/${1##*/}"
    else
        upstream="$to_remote/$1"
    fi
    git rev-parse --verify -q "$upstream" &>/dev/null || return 1
    branches_synced '.' "refs/remotes/$upstream" \
        "refs/heads/$1" && return 1
    return 0
}

# Make sure everything is up to date, and then figure out what barclamps
# and branches need pull requests on Github.  Once we have that figured out,
# print out a command line that can be used by dev pull-requests-gen to
# actually generate the pull requests.
pull_requests_prep() {
    remote_available personal && remote_is_github personal || \
        die "No personal remote available at Github.  Cannot do pull requests."
    crowbar_is_clean || exit 1
    fetch_all && sync_everything || \
        die "Unable to synchronize remotes for pull requests"
    local -A barclamps branches_to_push
    local barclamps_to_push=()
    local to_remote="$(origin_remote)"
    [[ $DEV_TO_REMOTES ]] && to_remote="$DEV_TO_REMOTES"
    remote_is_github "$to_remote" || \
        die "Cannot issue pull requests for $to_remote, it is not from github."
    local branch bc
    for branch in $(branches_for_release $(current_release)); do
        for bc in $(barclamps_from_branch "$branch"); do
            in_barclamp "$bc" branch_needs_pull_req \
                "${DEV_BRANCH_PREFIX}master" || continue
            barclamps_to_push+=("$bc/${DEV_BRANCH_PREFIX}master")
        done
        in_repo branch_needs_pull_req "$branch" || continue
        branches_to_push["$branch"]="true"
    done
    [[ ${!branches_to_push[*]} || ${barclamps_to_push} ]] || {
        echo "Everything up to date, no pull requests are possible."
        return 0
    }
    echo "Barclamps to update: ${barclamps_to_push[*]-(none)}"
    echo -n "Branches to update: "
    [[ ${!branches_to_push[*]} ]] && echo "${!branches_to_push[*]}" || \
        echo "(none)"
    echo "Command to generate pull requests:"
    echo -n "$0 pull-requests-gen --to $to_remote"
    [[ ${!branches_to_push[*]} ]] && \
        echo -n " --branches ${!branches_to_push[*]}"
    [[ ${barclamps_to_push[*]} ]] && \
        echo -n " --barclamps ${barclamps_to_push[*]}"
    echo
}

# Actaully generate a pull request by using make_pull_request to
# create the JSON blob that github needs, and then posting that to the
# right URL at Github.
do_pull_request() {
    # $1 = url to POST to
    # rest of args passed verbatim to make_pull_request helper.
    local posturl="$1"
    local -A res
    shift
    if [[ $DEBUG ]]; then
        make_pull_request "$@"
        return
    fi
    . <(make_pull_request "$@" | \
        curl_and_res -X POST --data @- \
        -H "Content-Type: application/vnd.github.beta.raw+json" \
        "$posturl" |parse_yml_or_json - res 2>/dev/null) || {
        echo "Pull request to $posturl with following params failed:"
        echo "$@"
        echo "Please delete the ones that succeeded and try again."
        exit 1
    }
    if [[ ${res['number']} && ${res['html_url']} ]]; then
        printf "Pull request %s created (%s)\n" \
            "${res['number']}" "${res['html_url']}"
    else
        echo "Pull request to $posturl with following params failed:"
        echo "$@"
        echo "Please delete the ones that succeeded and try again."
        exit 1
    fi
}

# Get the diffstat from the origin branch of the branch passed,
# or print an error message if there is no origin.
diffstat_from_upstream() {
    local upstream=''
    if [[ $1 = feature/* ]]; then
        upstream="$to_remote/${1##*/}"
    else
        upstream="$to_remote/$1"
    fi
    if git rev-parse --verify -q "$upstream" &>/dev/null; then
        git diff --stat "$upstream" "$1"
    else
        echo "No origin to generate diffstat"
    fi
}

git_ref() {
    # $1 = branch
    printf "%s-%s" "${1//\//-}" "$(git show-ref --hash=10 "refs/heads/$1")"
}

# Make pull requests based on the command line args passed.
# These should follow the command line arguments that
# pull_requests_prep generated.
pull_requests_gen() {
    # $@ = options to parse
    dev_is_setup || die "You must run dev setup before trying to generate pull requests."
    remote_available personal && remote_is_github personal || \
        die "No personal remote available at Github.  Cannot do pull requests."
    local -A barclamps branches barclamp_branches bc_pulls br_pulls refs
    local bc br bcr title body option bc_name head
    local prc=0 n=1
    local to_remote="$(origin_remote)"
    [[ $DEV_TO_REMOTES ]] && to_remote="$DEV_TO_REMOTES"
    local to_account="$(remote_github_account "$to_remote")" || \
        die "Cannot issue pull requests for $to_remote, it is not from github."
    body="$(mktemp /tmp/crowbar-pull-req-XXXXXXXX)"
    if [[ $DEBUG ]]; then
        title="Test"
        echo "test" >> "$body"
    else
        echo "Enter a title for this pull request series."
        echo "After you have entered a title, an editor will open, and you can"
        echo "enter anything you want for the body of the pull requests."
        read -p "Title: " title
        if [[ $EDITOR ]]; then
            $EDITOR "$body"
        else
            nano "$body"
        fi
    fi
    # Parse our options and validate them.
    while [[ "$1" ]]; do
        case $1 in
            --branches)
                shift
                while [[ $1 && $1 != '--'* ]]; do
                    br="$1"
                    shift
                    in_repo branch_exists "$br" || \
                        die "$br is not a branch in Crowbar!"
                    in_repo git_remote_exists "$to_remote" || \
                        die "Cannot make pull request to $to_remote, we don't know about it."
                    branches["$br"]="true"
                done;;
            --barclamps)
                shift
                while [[ $1 && $1 != '--'* ]]; do
                    bc="${1%%/*}"
                    br="${1#*/}"
                    [[ $bc = $br ]] && br="${DEV_BRANCH_PREFIX}master"
                    shift
                    in_barclamp "$bc" branch_exists "$br" || \
                        die "$br is not a branch in barclamp $bc!"
                    [[ $br = *master ]] || \
                        die "Non-master branch for a barclamp passed.  Not valid for now."
                    in_barclamp "$bc" git_remote_exists "$to_remote" || \
                        die "Cannot make pull request from barclamp $bc -- it is not present at remote $to_remote!"
                    barclamps["$bc"]="true"
                    is_in "$br" "${barclamp_branches["$bc"]}" || \
                        barclamp_branches["$bc"]+=" $br"
                done;;
            *) die "Unknown option $1 to $0 pull-requests-gen!";;
        esac
    done
    # The logic here is:
    # Find the "most central" branch for the current set of pull reqs.
    # Record that we need pull requests for each item we find.
    # lather, rinse, repeat until we are out of branches.

    for br in $(branches_for_release); do
        # Skip any branches that are not in the current release.
        in_repo branch_in_remote "$to_remote" "$br" || continue
        local parent="$(parent_branch "$br")"
        if [[ $parent && ${refs[$parent]} ]]; then
            refs["$br"]="$(in_repo git rev-parse --verify -q "refs/heads/$br")"
            in_repo quiet_checkout "$br"
            in_repo git merge -q "$parent"
        fi
        for bc in $(barclamps_from_branch "$br"); do
            [[ ${barclamps[$bc]} ]] || continue
            for bcb in ${barclamp_branches["$bc"]}; do
                bc_pulls["$bc/$bcb"]="pull-req-$(in_barclamp "$bc" git_ref "$bcb")"
            done
            # If we get this far, we have barclamp references to update.
            if [[ ! ${refs["$br"]} ]]; then
                # We had not already saved a reference for this branch.
                # Make sure we save a refeence to the current branch if we have
                # not already, then check out the branch of interest and
                # save a ref to it.
                [[ $head ]] || head="$(in_repo git symbolic-ref HEAD)" || \
                    die "pull-requests-gen: Crowbar not on a branch!"
                if ! [[ $(in_repo git symbolic-ref HEAD) = "refs/heads/$br" ]]
                then
                    in_repo quiet_checkout "$br" || \
                    die "pull-requests-gen: Could not checkout $br"
                fi
                refs["$br"]="$(in_repo git rev-parse --verify -q "refs/heads/$br")"
            fi
            in_repo git add "barclamps/$bc"
        done
        if [[ ${refs["$br"]} ]]; then
            in_repo git commit -m "Add updated submodule references for $br"
            # ... and push it to our personal github repo.
            br_pulls["$br"]="pull-req-$(in_repo git_ref "$br")"
        fi
        if [[ ${branches["$br"]} && ! ${br_pulls["$br"]} ]]; then
            br_pulls["$br"]="pull-req-$(in_repo git_ref "$br")"
        fi
    done
    # OK, now we know how many pull requests we have to issue.
    prc=$((${#bc_pulls[@]} + ${#br_pulls[@]}))

    # issue the pull requests for our barclamps.
    for barclamp in "${!bc_pulls[@]}"; do
        local bc=${barclamp%%/*}
        local bc_base=${barclamp#*/}
        in_barclamp "$bc" git_push personal "$bc_base:${bc_pulls[$barclamp]}"
        local bc_head="$DEV_GITHUB_ID:${bc_pulls[$barclamp]}"
        if [[ $bc_base = feature/* ]]; then
            bc_base="$(best_parent_prefix)${bc_base##*/}" || exit 1
        fi
        local bc_name=$(in_barclamp $bc git_url_for_remote $to_remote)
        bc_name=${bc_name##*/}
        bc_name=${bc_name##*:}
        bc_name=${bc_name%.git}
        do_pull_request \
            "https://api.github.com/repos/$to_account/$bc_name/pulls" \
            --title "$title [$n/$prc]" --base "$bc_base" --head "$bc_head" \
            --body "@$body" \
            --body "$(in_barclamp "$bc" diffstat_from_upstream "$bc_base")"
        n=$(($n + 1))
    done

    # Now, issue the requests for branches.
    # Make sure they are ordered correctly.
    for br in $(branches_for_release); do
        [[ ${br_pulls["$br"]} ]] || continue
        in_repo git_push personal "${br}:${br_pulls[$br]}"
        local br_head="$DEV_GITHUB_ID:${br_pulls[$br]}"
        if [[ $br = feature/* ]]; then
            br="$(best_parent_prefix)${br##*/}" || exit 1
        fi
        do_pull_request \
            "https://api.github.com/repos/$to_account/crowbar/pulls" \
            --title "$title [$n/$prc]" --base "$br" --head "$br_head" \
            --body "@$body" --body "$(in_repo diffstat_from_upstream "$br")"
        n=$(($n + 1))
        if [[ ${refs["$br"]} ]]; then
            in_repo quiet_checkout "$br"
            in_repo git reset --hard "${refs[$br]}"
        fi
    done
    [[ $head ]] && in_repo quiet_checkout "${head#refs/heads/}"
    rm -f "$body"
}

# Unconditionally push either the current branch or the branches
# passed on the command line to the personal remote.
push_branches() {
    # $@ = Local branches to push
    dev_is_setup || die "You must run dev setup before pushing branches to Github."
    remote_available personal && remote_is_github personal || \
        die "No personal remote available at Github.  Cannot do pull requests."
    local branches=("$@") br btp=()
    [[ $branches ]] || br=($(in_repo git symbolic-ref HEAD)) || \
        die "Main Crowbar repo is not on a branch we can push!"
    [[ $br ]] && branches=("${br#refs/heads/}")
    for br in "${branches[@]}"; do
        if in_repo git rev-parse --verify -q "$br" &>/dev/null; then
            btp+=("$br")
        else
            echo "$br is not a branch I can push!"
        fi
    done
    echo "Pushing ${btp[*]} to your Github fork of Crowbar."
    in_repo git_push personal "${btp[@]}"
}

# Show the releases that either the local repo or the origin repo knows about.
show_releases() {
    local sum ref r rtype
    local br_re='^(refs/(heads|remotes/([^/]+))/)'
    local -A releases
    while read sum ref; do
        [[ $ref =~ $br_re ]] || continue
        ref=${ref#${BASH_REMATCH[1]}}
        case ${ref} in
            master) r=development; rtype=development;;
            stable/master) r=stable; rtype=stable;;
            feature/*) r="${ref%/*}"; rtype=feature;;
            release/*)
                r="${ref#release/}"
                r=${r%%/*}
                rtype=release;;
        esac
        [[ ${releases["$r"]} ]] && continue
        releases["$r"]="$rtype"
    done < <(in_repo git show-ref master)
    for rtype in development stable release feature; do
        for r in "${!releases[@]}"; do
            [[ ${releases[$r]} = $rtype ]] || continue
            ref=$(in_repo remote_for_branch "$(branch_prefix "$r")master")
            echo "$r"
        done |sort
    done
}

release_exists() {
    # $1 = release to test for the existence of
    grep -qFx "$1" < <(show_releases)
}

# Given a release name, give us the proper brach prefix for it.
branch_prefix() {
    # $1 = release name
    case $1 in
        development) : ;;
        stable) echo "stable/";;
        feature/*) echo "$1/";;
        *) echo "release/$1/";;
    esac
}

# Given a branch, figure out what release it is in.
release_for_branch() {
    # $1 = branch to find out what release we are on
    local br=${1#refs/heads/}
    case $br in
        stable/*) echo "stable";;
        release/*) br=${br#release/}; echo "${br%%/*}";;
        feature/*) br=${br#feature/}; echo "feature/${br%%/*}";;
        *)
            if in_repo git_config_has "crowbar.branch.$br.parent"; then
                echo "development"
            else
                die "Not on a release branch"
            fi;;
    esac
}

# Given a release, find the "best" parent release.  This will only
# be called if we don't already have metadata recorded for the
# parent relationship of this release.
find_best_parent() {
    # $1 = release to find the "best" parent of.
    #      If empty, use the release we are currently on.
    local br distance best_distance ref candidate merge_base release
    local best_candidates=()
    if [[ $1 ]]; then
        release_exists "$1" || \
            die "find_best_parents: $1 is not a release"
        release="$1"
    else
        release="$(release_for_branch $(in_repo git symbolic-ref HEAD))"
    fi
    [[ $release = development ]] && \
        die "By definition, the development release has no logical parent."

    if in_repo git_config_has "crowbar.releases.$1.parent"; then
        get_repo_cfg "crowbar.releases.$1.parent"
        return 0
    fi

    br="$(branch_prefix "$release")master"
    # Find the target that is the smallest number of commits away from us.
    # There may be more than one.  This algorithim is OK for a first pass,
    # but there are more complex and more accurate solutions out there.
    while read ref candidate; do
        candidate=${candidate#refs/heads/}
        [[ $candidate = $br ]] && continue
        distance="$(in_repo git rev-list --count --right-only "$candidate...$br")"
        [[ $best_distance ]] || best_distance=$distance
        if (( distance < best_distance )); then
            best_distance=$distance
            best_candidates=("$(release_for_branch "$candidate")")
        elif (( distance == best_distance )); then
            best_candidates+=("$(release_for_branch "$candidate")")
        fi
    done < <(git show-ref --heads master)
    local VERBOSE=1
    if (( ${#best_candidates[@]} == 0 )); then
        die "No best parent found for $release"
    elif (( ${#best_candidates[@]} == 1 )); then
        debug "It looks like $best_candidates is the parent of $release"
        candidate="$best_candidates"
    else
        debug "More than one good candidate for a parent of $release found."
        debug "Please pick the one you want:"
        select candidate in "${best_candidates[@]}" "None of the above"; do
            case $candidate in
                'None of the above') die "Aborting.";;
                '') continue;;
                *) break;;
            esac
        done
    fi
    in_repo git config "crowbar.releases.$1.parent" "$candidate"
}

best_parent_prefix() {
    local res
    res="$(find_best_parent "$1")"
    echo "$(branch_prefix "$res")"
}

DEV_BRANCH_PREFIX="$(branch_prefix $(current_release))"

# Create a new release branch structure based on the current state of the
# Crowbar repositories.
cut_release() {
    local b remote old_prefix new_prefix
    local old_release new_release
    local -A barclamps branches

    [[ $1 ]] || die "cut_release: Please specify a name for the new release"

    # Test to see if release exists.
    release_exists "$1" && die "cut_release: Name already exists"

    old_release="$(current_release)"
    old_prefix="$(branch_prefix "$old_release")"
    new_prefix="$(branch_prefix $1)"
    crowbar_is_clean || \
        die "Crowbar repo must be clean before trying to cut a release!"

    # Sanoty-check that all the branches
    for b in $(branches_for_release); do
        branches["$b"]="${new_prefix}${b##*/}"
    done

    for b in $(barclamps_in_branch "${!branches[@]}"); do
        barclamps[$b]="master"
    done

    # Actaully create the new branches.
    for b in "${!branches[@]}"; do
        in_repo git branch -f --no-track "${branches[$b]}" "$b"
    done

    for b in "${!barclamps[@]}"; do
        in_barclamp "$b" git branch -f --no-track "${new_prefix}master" \
            "${old_prefix}master"
    done
    if git_managed_cache && ! branch_exists "${new_prefix}master"; then
        if in_cache branch_exists "${old_prefix}master"; then
            in_cache git branch "${new_prefix}master" "${old_prefix}master"
        else
            in_cache git branch "${new_prefix}master" master
        fi
    fi
    in_repo git config "crowbar.releases.$1.parent" "$old_release"
}

show_branch_graph() {
    # $1 = release to show the branch for.
    # $2 = root of hierarchy to show
    # $3 = number of indents to print
    local x br children child remote prefix
    for ((x=0; x<${3}; x++)); do printf '\t'; done
    if [[ $1 ]]; then
        prefix=$(branch_prefix "$1") || die "$1 is not a release!"
        br="${prefix}${2}"
        remote="$(in_repo remote_for_branch "$br")" || remote="no remote!"
        children="$(child_branches "$br")"
        printf "%s (%s)" "$br" "$remote"
    else
        prefix=''
        br="$2"
        remote=''
        children="$(get_repo_cfg "crowbar.branch.$br.children")"
        printf "%s" "$br"
    fi
    if [[ $children ]]; then
        printf ':\n'
        for child in $children; do
            show_branch_graph "$1" "${child##*/}" "$(($3 + 1))"
        done
    else
        printf '\n'
    fi
}

set_branch_graph() {
    local node parent child roots=() node_re='^([^:/]+):([^:/]+)$'
    local -A nodes children
    # Build a hash table out of the nodes we were passed.
    for node in "$@"; do
        [[ $node =~ $node_re ]] || die "Invalid node $node passed to set_branch_graph."
        parent="${BASH_REMATCH[1]}"
        child="${BASH_REMATCH[2]}"
        # Disallow multiple parents per child.
        [[ ${nodes["$child"]} ]] && \
            die "Cannot give $child two parents ($parent and ${nodes[$child]}"
        nodes["$child"]="$parent"
    done
    # Mix in information from our current branch graph.
    for node in $(ordered_branches $(root_branches development)); do
        if parent=$(parent_branch "$node"); then
            if [[ ${nodes[$node]} && ${nodes[$node]} != $parent ]]; then
                die "$node already has $parent as its parent.
Making ${nodes[$node]} the parent of $node makes no sense."
            elif [[ ${nodes[$node]} && ${nodes[$node]} = $parent ]]; then
                continue
            else
                nodes["$node"]="$parent"
            fi
        elif [[ ${nodes[$node]} ]]; then
            if [[ $node = master ]]; then
                [[ ${nodes[$node]} = master ]] && continue
                die "master must always be a root branch.
Making ${nodes[$node]} its parent makes no sense."
            fi
                die "$node is a root branch, cannot make ${nodes[$node]} it's parent.
Detach $node from the branch graph if you really want to do this."
        else
            nodes["$node"]="$node"
        fi
    done
    # Verify that we are a tree, and not a cabbage or something.
    for node in "${!nodes[@]}"; do
        local -A found_nodes
        local pnode=$node
        while [[ ${nodes[$pnode]} != $pnode ]]; do
            [[ ${found_nodes[$pnode]} ]] && \
                die "Adding ${nodes[$node]}:$node would make the branch graph cyclical."
            found_nodes["$pnode"]=true
            [[ ${nodes[$pnode]} ]] || \
                die "No path from ${nodes[$node]}:$node to a root.
Disconnect happened at $pnode."
            pnode=${nodes[$pnode]}
        done
        unset found_nodes pnode
    done
    # Calculate root nodes and child nodes
    for node in $(printf "%s\n" ${!nodes[@]} |sort); do
        if [[ $node = ${nodes[$node]} ]]; then
            roots+=($node)
            continue
        fi
        parent=${nodes[$node]}
        [[ ${children[$parent]} ]] && children[$parent]+=" $node" || children[$parent]="$node"
    done
    # We are cool, save everything.
    [[ $roots ]] && in_repo git config "crowbar.roots" "${roots[*]}"
    for node in "${!nodes[@]}"; do
        in_repo git config "crowbar.branch.$node.parent" "${nodes[$node]}"
        [[ ${children[$node]} ]] || continue
        in_repo git config "crowbar.branch.$node.children" "${children[$node]}"
    done
}

destroy_branch_graph() {
    local child children parent
    parent="$(get_repo_cfg "crowbar.branch.$1.parent")" || \
        die "$1 is not in the branch graph!"
    if children="$(get_repo_cfg "crowbar.branch.$1.children")"; then
        for child in $children; do
            destroy_branch_graph "$child"
        done
        in_repo git config --unset "crowbar.branch.$1.children"
    fi
    children=''
    for child in $(get_repo_cfg "crowbar.branch.$parent.children"); do
        [[ $child && $child != $1 ]] || continue
        [[ $children ]] && children+=" $child" || children="$child"
    done
    in_repo git config "crowbar.branch.$parent.children" "$children"
    in_repo git config --unset "crowbar.branch.$1.parent"
}

branch_graph_handler() {
    case $1 in
        help) echo "Please pass one of show or set.";;
        show) show_branch_graph "$2" "master" "0";;
        add) shift; set_branch_graph "$@";;
        destroy) shift; destroy_branch_graph "$1";;
        *) show_branch_graph "$2" "master" "0";;
    esac
}

cut_feature() {
    [[ $1 ]] || die "Please give your new feature a name!"
    cut_release "feature/$1"
}

erase_release() {
    # $1 = release refix
    local b prefix parent parent_prefix
    [[ $1 = development ]] && die "Cannot erase the development release."
    release_exists "$1" || die "$1 is not a release we can erase!"
    prefix="$(branch_prefix "$1")"
    parent=$(find_best_parent "$1")
    parent_prefix=$(branch_prefix "$parent")
    if ! in_repo branches_synced '.' \
        "${parent_prefix}master" "${prefix}master"; then
        printf "$1 is not merged into $parent.  Really erase? (y/n): " >&2
        read -n 1
        [[ $REPLY != 'y' ]] && exit
    fi
    #    die "$1 is not merged into the development release, refusing to erase."
    for b in $(barclamps_in_branch $(branches_for_release "$1")); do
        in_barclamp "$b" git branch -D "${prefix}master"
    done
    for b in $(branches_for_release "$1"); do
        in_repo git branch -D "$b"
    done
}

# Check out the appropriate release branch for all the barclamps in a given
# release, and then check out the appropriate branch in the release.
switch_release() {
    local br bc current_branch new_base rel repo
    if [[ $1 ]]; then
        release_exists "$1" || die "switch: $1 does not exist"
        rel="$1"
    else
        rel="$(current_release)"
    fi
    crowbar_is_clean || \
        die "Crowbar repo must be clean before trying to switch releases!"

    new_base="$(branch_prefix "$rel")"

    current_branch=$(in_repo git symbolic-ref HEAD) || \
        die "switch: Crowbar not on a branch."
    current_branch=${current_branch##*/}
    in_repo branch_exists "${new_base}${current_branch}" || {
            echo "$rel does not have branch $current_branch, will checkout master instead."
        current_branch=master
    }
    in_repo quiet_checkout "${new_base}master"
    checkout "${current_branch}"
    if git_managed_cache && [[ $switch_include_cache ]]; then
        if in_cache branch_exists "${new_base}master"; then
            debug "Checking out ${new_base}master in the build cache, please be patient."
            in_cache quiet_checkout -f "${new_base}master"
        fi
    fi
    DEV_BRANCH_PREFIX="$new_base"
}

checkout() {
    local br new_base rel
    [[ $1 ]] || die "checkout: Please specify a branch"
    br=$1
    rel="$(current_release)"
    new_base=$(branch_prefix "$rel")
    in_repo branch_exists "${new_base}${br}" || \
        die "Branch $br does not exist in release $rel"
    in_repo git checkout "${new_base}${br}"
    switch_barclamps_to "${new_base}master"
}

build_crowbar() {
    local build_args=() b c target_os target_release exact
    local switch_include_cache=true
    target_release="$(current_release)"
    target_branch="$(in_repo git symbolic-ref HEAD)"
    target_branch="${target_branch##*/}"
    crowbar_is_clean || exit 1
    while [[ $1 ]]; do
        case $1 in
            --os) shift; target_os="$1";;
            --release) shift; target_release="$1";;
            --branch) shift; target_branch="$1";;
            --exact) exact=true;;
            *) build_args+=($1);;
        esac
        shift
    done
    [[ $target_os ]] || \
        die "Cannot build Crowbar, need to know what OS to stage it on!"
    update_all_tracking_branches
    build_args+=("--skip-lock")
    switch_release "${target_release:=$(current_release)}" || \
        die "Could not switch to $target_release for build!"
    [[ $target_branch ]] || die "Not on a branch, cannot continue!"
    checkout "$target_branch"
    if [[ $exact ]]; then
        in_repo git submodule update || \
            die "Could not check out submodule revisions for $target_release!"
    fi
    with_build_lock exec "$CROWBAR_DIR/build_crowbar.sh" \
        "$target_os" "${build_args[@]}"
}

reset_branch() {
    # $1 = branch to reset
    # $2 = target to reset it to.
    if [[ $(git symbolic-ref HEAD) = refs/heads/$1 ]]; then
        git reset --hard "$2"
    else
        git branch -f --no-track "$1" "$2"
    fi
}

reset_release() {
    crowbar_is_clean || exit 1
    local target_release target exclude_master prefix br remote
    local method bc skip_barclamps
    local -A branches barclamps barclamp_targets
    while [[ $1 ]]; do
        case $1 in
            --release) shift; target_release="$1";;
            --target) shift; target="$1";;
            --skip-master) exclude_master=true;;
            --skip-barclamps) skip_barclamps=true;;
            *) die "Unknown option $1 passed to reset-release";;
        esac
        shift
    done
    if [[ ! $target_release ]]; then
        exclude_master=true
        skip_barclamps=true
        target_release="$(current_release)"
    elif ! release_exists "$target_release"; then
        die "Release $target_release does not exist, cannot reset."
    fi
    if [[ ! $target ]]; then
        remote_available personal && remote_is_github personal || \
            die "No personal remote available at Github.  Cannot restore from backup."
        target=backup
    elif [[ ! $target =~ ^upstream|backup$ ]]; then
        die "Must reset to either upstream or backup!"
    fi
    prefix="$(branch_prefix "$target_release")"
    # Figure out what the proper target branches are going to be.
    for br in $(branches_for_release "$target_release"); do
        [[ $exclude_master && ${br##*/} = master ]] && continue
        remote="$(in_repo remote_for_branch "$br")"
        case $target in
            upstream) branches["$br"]="$remote/$br";;
            backup)   branches["$br"]=$(get_repo_cfg "crowbar.backup.$remote.remote")
                      branches["$br"]+="/$br";;
            *) die "Don't know how to reset to $target_method";;
        esac
        if ! in_repo git rev-parse --quiet --verify \
            "${branches[$br]}" &>/dev/null; then
            if [[ $target = backup ]]; then
                debug "$br has never been backed up, skipping."
                unset branches[$br]
            elif [[ $target = upstream ]]; then
                die "Cannot reset $br to ${branches[$br]}"
            fi
        fi
        [[ $skip_barclamps = true ]] && continue
        for bc in $(barclamps_from_branch "$br"); do
            [[ ${barclamps[$bc]} ]] && continue
            in_barclamp "$bc" branch_exists "${prefix}master" || continue
            barclamps[$bc]="${prefix}master"
            case $target in
                upstream) in_barclamp "$bc" git_remote_exists "$remote" || continue
                          barclamp_targets[$bc]="$remote/${prefix}master";;
                backup)   in_barclamp "$bc" git_remote_exists personal || continue
                          barclamp_targets[$bc]+="personal/${prefix}master";;
                *) die "Don't know how to reset barclamp $bc to $target_method";;
            esac
            if ! in_barclamp "$bc" git rev-parse --quiet --verify \
                "${barclamp_targets[$bc]}" &>/dev/null; then
                if [[ $target = backup ]]; then
                    debug "${barclamps[$bc]} in $bc has never been backed up, skipping."
                    unset barclamps[$bc]
                elif [[ $target = upstream ]]; then
                    debug "Cannot reset barclamp $bc to ${barclamp_targets[$bc]}"
                    unset barclamps[$bc]
                fi
            fi
        done
    done
    for bc in "${!barclamp_targets[@]}"; do
        in_barclamp "$bc" branch_exists "${barclamps[$bc]}" || continue
        in_barclamp "$bc" \
            reset_branch "${barclamps[$bc]}" "${barclamp_targets[$bc]}"
    done
    for br in "${!branches[@]}"; do
        in_repo reset_branch "$br" "${branches[$br]}"
    done
}

setup_unit_tests() {
  rm -rf /tmp/crowbar
  mkdir /tmp/crowbar
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  mkdir -p /tmp/crowbar/barclamps/templates
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  cp -r barclamps/*/chef/data_bags/crowbar/*.json /tmp/crowbar/barclamps/templates
  for i in barclamps/*/crowbar.yml; do
    cp "$i" "/tmp/crowbar/barclamps/`basename $(dirname $i)`.yml"
  done

  cd /tmp/crowbar
  BUNDLE="bundle"
  type bundle 2>/dev/null >/dev/null || BUNDLE="/var/lib/gems/1.8/bin/bundle"
  type $BUNDLE || echo "MUST HAVE BUNDLER"
  sed -ie 's/^source .*/source "http:\/\/rubygems.org"/' "Gemfile"
  $BUNDLE
  cd ..

  cd /tmp/crowbar/BDD
  sudo /tmp/crowbar/BDD/linux_install.sh
  ./linux_compile.sh
  cd -
}

reload_unit_tests() {
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  mkdir -p /tmp/crowbar/barclamps/templates
  cp -r barclamps/*/crowbar_framework/* /tmp/crowbar
  cp -r barclamps/*/chef/data_bags/crowbar/*.json /tmp/crowbar/barclamps/templates
  for i in barclamps/*/crowbar.yml; do
    cp "$i" "/tmp/crowbar/barclamps/`basename $(dirname $i)`.yml"
  done

  cd /tmp/crowbar
  RAKE="rake"
  type rake 2>/dev/null >/dev/null || RAKE="/var/lib/gems/1.8/bin/rake"
  type $RAKE || echo "MUST HAVE RAKE"
  $RAKE db:drop
  $RAKE db:migrate
  $RAKE db:fixtures:dump
  cd -
 
  cd /tmp/crowbar/BDD
  ./linux_compile.sh
  sed -ie 's/192.168.124.10/127.0.0.1/' "crowbar.config"
  cd -
}

run_unit_tests() {
  # Run unit tests
  cd /tmp/crowbar
  RAKE="rake"
  type rake 2>/dev/null >/dev/null || RAKE="/var/lib/gems/1.8/bin/rake"
  type $RAKE || echo "MUST HAVE RAKE"
  $RAKE test:units
  cd -

  # Run BDD tests
  cd /tmp/crowbar/BDD
  ./linux_run.sh
  cd -
}

clear_unit_tests() {
  rm -rf /tmp/crowbar
}

in_repo origin_remote >&/dev/null || \
    [[ $1 = setup ]] || \
    die "Unable to find origin account, please run setup!"

# Handle some global option parsing.
# This is mainly for --from and --to handling.
parse_opts_and_go() {
    local genargs=()
    while (( $# > 0)); do
        case $1 in
            --from) shift
                in_repo git_remote_exists "$1" || \
                    die "You must pass a configured remote for --from."
                [[ ${DEV_FROM_REMOTES} ]] || DEV_FROM_REMOTES=()
                DEV_FROM_REMOTES+=("$1");;
            --to) shift
                in_repo git_remote_exists "$1" || \
                    die "You must pass a configured remote for --to."
                [[ ${DEV_TO_REMOTES} ]] || DEV_TO_REMOTES=()
                DEV_TO_REMOTES+=("$1");;
            *) genargs+=("$1");;
        esac
        shift
    done
    set -- "${genargs[@]}"
    case "$1" in
        is_clean) shift; crowbar_is_clean "$@";;
        fetch) shift; fetch_all "$@";;
        sync) shift; sync_everything "$@";;
        setup) setup;;
        backup) shift; backup_everything "$@";;
        push) shift; push_branches "$@";;
        pull-requests-prep) pull_requests_prep;;
        pull-requests-gen) shift; pull_requests_gen "$@";;
        help) dev_help;;
        release) current_release;;
        releases) show_releases;;
        cut_release) shift; cut_release "$@";;
        new-feature) shift; cut_feature "$1";;
        switch) shift; switch_release "$@";;
        branches) shift; branches_for_release "$@";;
        branch-graph) shift; branch_graph_handler "$@";;
        checkout) shift; checkout "$@";;
        build) shift; build_crowbar "$@";;
        remote) shift; remote_wrapper "$@";;
        erase-feature) shift; erase_release "feature/$1";;
        find-parent) shift; find_best_parent "$@";;
        reset-release) shift; reset_release "$@";;
        scrub-merged-pulls) shift; scrub_merged_pulls "$@";;
        setup-unit-tests) setup_unit_tests;;
        reload-unit-tests) reload_unit_tests;;
        run-unit-tests) run_unit_tests;;
        clear-unit-tests) clear_unit_tests;;
        create-barclamp) shift
            [[ -d $CROWBAR_DIR/barclamps/$1 ]] || \
                die "Barclamp $1 already exists"
            "$CROWBAR_DIR/extra/barclamp_create.rb" "$@" || exit 1
            (   cd "$CROWBAR_DIR/barclamps/$1"
                git init .
                git add .
                git commit -m "Initial commit"
            );;
        *) dev_short_help; exit 1;;
    esac
}

parse_opts_and_go "$@"

